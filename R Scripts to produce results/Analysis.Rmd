---
title: "Results Analysis of Large-scale User Study"
output: 
  pdf_document:
    latex_engine: pdflatex
header-includes:
  - \usepackage[utf8]{inputenc}
  - \usepackage[T1]{fontenc}
---

# Introduction

This document presents an analysis of the data acquired in the "Explanation Game" from a large-scale user study conducted in the start of March 2024.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```

```{r results='asis', echo=FALSE, include=FALSE,}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE)

library(rstudioapi)
library(ggplot2)
library(ggrepel)
library(plyr)
library(dplyr)
# Suppress summarise info
options(dplyr.summarise.inform = FALSE)
library(unikn)
library(ggpubr)
library(data.table)
library(tidyverse)
library(scales)
library(effsize)

########
## UK: 
# for the lme approach: - COMMENT UK: not used here:
#library("emmeans")
#library("sjstats")
#library("lme4")
#library("lmerTest")
#library("MuMIn")

# for Dunn's Test (Kruskal-Wallis Posthoc):
library(FSA)
library(rstatix)
########

# turn off scientific notation for exact values
options(scipen = 999)

# Barrier-free color palette
# Source: Okabe & Ito (2008): Color Universal Design (CUD):
#         Fig. 16 of <https://jfly.uni-koeln.de/color/>:

# (a) Vector of colors (as RGB values):
Okabe_Ito_palette <- c(rgb(  0,   0,   0, maxColorValue = 255),  # black
                rgb(230, 159,   0, maxColorValue = 255),  # orange
                rgb( 86, 180, 233, maxColorValue = 255),  # skyblue
                rgb(  0, 158, 115, maxColorValue = 255),  # green
                rgb(240, 228,  66, maxColorValue = 255),  # yellow
                rgb(  0, 114, 178, maxColorValue = 255),  # blue
                rgb(213,  94,   0, maxColorValue = 255),  # vermillion
                rgb(204, 121, 167, maxColorValue = 255)   # purple
)

# (b) Vector of color names:
o_i_names <- c("black", "orange", "skyblue", "green", "yellow", "blue", "vermillion", "purple")

# (c) Use newpal() to combine colors and names:
pal_okabe_ito <- newpal(col = Okabe_Ito_palette,
                        names = o_i_names)

Ccol=Okabe_Ito_palette[3]
Ucol=Okabe_Ito_palette[4]
Dcol=Okabe_Ito_palette[2]

# palette for likert scale data, inspired by yellow and vermillion values from Okabe_Ito
likert_Okabe_Ito_palette <- c(rgb(213,  94,   0, maxColorValue = 255),  # vermillion (strongly disagree)
                rgb(234, 175, 128, maxColorValue = 255),  # middle yellow red (disagree)
                rgb(255, 255, 255, maxColorValue = 255),  # white (neutral)
                rgb(249, 245, 179, maxColorValue = 255),  # medium champagne (agree)
                rgb(240, 228,  66, maxColorValue = 255)   # yellow (strongly agree)
)

# set an empty string to save all information
matchingRes=""
matchingRes="Comparison,ShapiroPval,TestUsed,TestPval,TestEffSize"

# source adapted wilcoxon test (easy computation of effect size) 
source("uk_wilcox.test.R")
# tinytex::reinstall_tinytex(repository = "illinois")

```


# Data Cleaning and Data Statistics 

```{r echo=FALSE, warning=FALSE}

# Read the CSV file
#file_path <- 'C:\\Users\\laboratorio\\Documents\\VPS\\survey.csv'  

survey_source = list.files(path = "./mergedfiles", pattern="survey.csv",full.names=TRUE)
demo_source = list.files(path = "./mergedfiles", pattern="demographics.csv",full.names=TRUE)
perf_source = list.files(path = "./mergedfiles", pattern="performance.csv",full.names=TRUE)
rt_source = list.files(path = "./mergedfiles", pattern="reactionTime.csv",full.names=TRUE)

df_demo=read.csv(demo_source,header=TRUE)
df_survey=read.csv(survey_source,header=TRUE)
df_perf=read.csv(perf_source,header=TRUE)
df_rt=read.csv(rt_source,header=TRUE)


#######
## UK: this old remainder from my previous analysis falsely removed valid lines of data! DO NOT USE!
#df_survey=df_survey[!duplicated(df_survey),]
#df_demo=df_demo[!duplicated(df_demo),]
#df_perf=df_perf[!duplicated(df_perf),]
#df_rt=df_rt[!duplicated(df_rt),]
#######

# correct item number in survey df if zero based
if(0 %in% df_survey$itemNo){
df_survey$itemNo=df_survey$itemNo+1
}

# sort according to user ID and planet number:
df_perf=df_perf[order(df_perf$userId, df_perf$planetNo),]
df_rt=df_rt[order(df_rt$userId, df_rt$planetNo),]
df_survey=df_survey[order(df_survey$userId, df_survey$itemNo),]
df_demo=df_demo[order(df_demo$userId),]

numSurveyItems=max(df_survey$itemNo)
print("Before removing dupliacte participants:")
cat("Participants played the game:",perf_user_count <- length(unique(df_perf$userId)), '\n')
cat("Participants filled the post-game survey:",survey_user_count <- length(unique(df_survey$userId)), '\n')
cat("Participants played game, filled the post-game and demographic questionnaire:",demo_user_count <- length(unique(df_demo$userId)), '\n')

# duplicates
# duplicates=aggregate(data=df_perf, group~userId, function(x) length(unique(x)))

# duplicates to remove
remove_duplicate_users <- function(df) {
  duplicate_userIds <- df %>%
    group_by(userId) %>%
    filter(n_distinct(group) > 1 & any(group == 'C')) %>%
    pull(userId)
  return(duplicate_userIds)
}

# identifying the duplictae userid's across the data df's
duplicate_userIds_perf <- remove_duplicate_users(df_perf)
duplicate_userIds_demo <- remove_duplicate_users(df_demo)
duplicate_userIds_survey <- remove_duplicate_users(df_survey)
duplicate_userIds_rt <- remove_duplicate_users(df_rt)

# Remove rows with duplicate userIds from data df's
df_perf <- df_perf[!df_perf$userId %in% duplicate_userIds_perf, ]
df_demo <- df_demo[!df_demo$userId %in% duplicate_userIds_demo, ]
df_survey <- df_survey[!df_survey$userId %in% duplicate_userIds_survey, ]
df_rt <- df_rt[!df_rt$userId %in% duplicate_userIds_rt, ]

cat("after removing the duplicate participants:",'\n')
cat("Participants played the game:",perf_user_count <- length(unique(df_perf$userId)), '\n')
cat("(Control, UFCE, DiCE) :", length(unique(df_perf$userId[df_perf$group=="C"])), length(unique(df_perf$userId[df_perf$group=="U"])), length(unique(df_perf$userId[df_perf$group=="D"])), '\n')

cat("Participants filled the post-game survey:",survey_user_count <- length(unique(df_survey$userId)), '\n')
cat("(Control, UFCE, DiCE) :", length(unique(df_survey$userId[df_survey$group=="C"])), length(unique(df_survey$userId[df_survey$group=="U"])), length(unique(df_survey$userId[df_survey$group=="D"])), '\n')

cat("Participants played game, filled the post-game and demographic questionnaire:",demo_user_count <- length(unique(df_demo$userId)), '\n')
cat("(Control, UFCE, DiCE) :", length(unique(df_demo$userId[df_demo$group=="C"])), length(unique(df_demo$userId[df_demo$group=="U"])), length(unique(df_demo$userId[df_demo$group=="D"])), '\n')

```

## General infos after removal of incomplete datasets

How many users do we have in our demographics df before any cleaning (i.e., also including users with incomplete datasets)? `r length(unique(df_demo$userId))`

Of those, 

* `r length(unique(df_demo$userId[df_demo$group=="C"]))` participants were in the control condition and 

* `r length(unique(df_demo$userId[df_demo$group=="U"]))` participants in the UFCE condition, and

* `r length(unique(df_demo$userId[df_demo$group=="D"]))` participants in the DiCE condition

## Check covariates across groups

Additionally to assessing performance, we also acquire age and gender information of participants.
How do our groups look like? Are the groups comparable?


```{r echo=FALSE, warning=FALSE,fig.height = 4, fig.width = 3.5}

# get only age info
df_demo_age = df_demo[df_demo$item=='age',]
df_demo_gender = df_demo[df_demo$item=='gender',]

# summarize to get overview values of frequencies and percentages
df_demo_age_summary=dplyr::summarise(group_by(df_demo_age, group, item, responseNo),
          SumChecks=sum(checked),
          PercUsersChecked=100*(sum(checked)/length(unique(userId))))

# summarize to get overview values of frequencies and percentages
df_demo_gender_summary=dplyr::summarise(group_by(df_demo_gender, group, item, responseNo),
          SumChecks=sum(checked),
          PercUsersChecked=100*(sum(checked)/length(unique(userId))))

# convert to factor for proper plotting:
df_demo_age_summary$responseNo=as.factor(df_demo_age_summary$responseNo)
df_demo_gender_summary$responseNo=as.factor(df_demo_gender_summary$responseNo)

# AGE: display frequency as raw counts
CovAge_FreqUserResponses = ggplot(data=df_demo_age_summary, aes(x=responseNo,fill = group)) + 
  geom_bar(aes(y = SumChecks),stat="identity",position = position_dodge(preserve = "single"))+
  labs(title="Age of participants (freq. counts)",x="", y = "Frequency of answer")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Ccol,Dcol,Ucol), labels = c("Control", "DiCE", "UFCE"))+
  scale_x_discrete(breaks=1:7, labels=c("18-24y","25-34y","35-44y","45-54y","55-64y","65 and\nover","Prefer not\nto answer"))+
  theme(plot.title = element_text(hjust = 0.5),axis.text.x = element_text(angle = 60,hjust = 0.95))

# AGE: display frequency as percentage
CovAge_PercUserResponses = ggplot(data=df_demo_age_summary, aes(x=responseNo,fill = group)) + 
  geom_bar(aes(y = PercUsersChecked),stat="identity",position = position_dodge(preserve = "single"))+
  labs(title="Age of participants (% of users)",x="", y = "% of users")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Ccol,Dcol,Ucol), labels = c("Control", "DiCE", "UFCE"))+
  scale_x_discrete(breaks=1:7, labels=c("18-24y","25-34y","35-44y","45-54y","55-64y","65 and\nover","Prefer not\nto answer"))+
  theme(plot.title = element_text(hjust = 0.5),axis.text.x = element_text(angle = 60,hjust = 0.95))

# put plots together
figure_CovAgeRaw <- ggarrange(CovAge_FreqUserResponses,CovAge_PercUserResponses,
                    ncol = 1, nrow = 2, align = "v")
# save
ggsave("Figures/CovAgeRaw_distribution.pdf",width = 9, height = 7,)

# show 
figure_CovAgeRaw

# GENDER: display frequency as raw counts
CovGender_FreqUserResponses = ggplot(data=df_demo_gender_summary, aes(x=responseNo,fill = group)) + 
  geom_bar(aes(y = SumChecks),stat="identity",position = position_dodge(preserve = "single"))+
  labs(title="Gender of participants (freq. counts)",x="", y = "Frequency of answer")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Ccol,Dcol,Ucol), labels = c("Control", "DiCE", "UFCE"))+
  scale_x_discrete(breaks=1:6, labels=c("Female","Male","Transgender","Non-binary","Not listed","Prefer not\nto answer"))+
  ylim(0, 40)+
  theme(plot.title = element_text(hjust = 0.5),axis.text.x = element_text(angle = 60,hjust = 0.95))

# GENDER: display frequency as percentage
CovGender_PercUserResponses = ggplot(data=df_demo_gender_summary, aes(x=responseNo,fill = group)) + 
  geom_bar(aes(y = PercUsersChecked),stat="identity",position = position_dodge(preserve = "single"))+
  labs(title="Gender of participants (% of users)",x="", y = "% of users")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Ccol,Dcol,Ucol), labels = c("Control", "DiCE", "UFCE"))+
  scale_x_discrete(breaks=1:6, labels=c("Female","Male","Transgender","Non-binary","Not listed","Prefer not\nto answer"))+
  #ylim(0, 70)+
  theme(plot.title = element_text(hjust = 0.5),axis.text.x = element_text(angle = 60,hjust = 0.95))

# put plots together 
figure_CovGenderRaw <- ggarrange(CovGender_FreqUserResponses,CovGender_PercUserResponses,
                    ncol = 1, nrow = 2, align = "v")
# save
ggsave("Figures/CovGenderRaw_distribution.pdf",width = 9, height = 7,)

# show 
figure_CovGenderRaw
```

##### average Age of different groups
```{r echo=FALSE, warning=FALSE}

########
## UK: remove participants without conclusive gender / age information already for 
# finding the median age group:
userIDs_no_age=df_demo_age$userId[df_demo_age$responseNo==7 & df_demo_age$checked==1]
userIDs_no_gender=df_demo_gender$userId[df_demo_gender$responseNo==6 & df_demo_gender$checked==1]

df_demo_age=df_demo_age[!df_demo_age$userId %in% userIDs_no_age, ]
df_demo_gender=df_demo_gender[!df_demo_gender$userId %in% userIDs_no_gender, ]

# summarize to get overview values of frequencies and percentages
df_demo_age_summary=dplyr::summarise(group_by(df_demo_age, group, item, responseNo),
          SumChecks=sum(checked),
          PercUsersChecked=100*(sum(checked)/length(unique(userId))))

# summarize to get overview values of frequencies and percentages
df_demo_gender_summary=dplyr::summarise(group_by(df_demo_gender, group, item, responseNo),
          SumChecks=sum(checked),
          PercUsersChecked=100*(sum(checked)/length(unique(userId))))

########

# average age of each group
# statistical differences between groups?
medianAge_C=cumsum(df_demo_age_summary$SumChecks[df_demo_age_summary$group=="C"])
medianAge_U=cumsum(df_demo_age_summary$SumChecks[df_demo_age_summary$group=="U"])
medianAge_D=cumsum(df_demo_age_summary$SumChecks[df_demo_age_summary$group=="D"])

########
## UK: report median age groups:
# C = 26ppl (without "no answer") --> 13/14th person --> 1st age band
# U = 23 (without "no answer") --> 12th person --> 2nd age band
# D = 35 (without "no answer") --> 18th person --> 1st age band
########

########
## UK: taken out here, as I did it a little earlier to find the proper median age
## count users who 'prefered not to answer'
#N_noAnswer_age=nrow(df_demo_age[df_demo_age$responseNo==7 & df_demo_age$checked==1,])
#N_noAnswer_gender=nrow(df_demo_gender[df_demo_gender$responseNo==7 & df_demo_gender$checked==1,])

# remove 'prefer not to answer' entries
#df_demo_age = df_demo_age[!df_demo_age$responseNo==7,]
df_demo_age_responses=df_demo_age[!df_demo_age$checked==0,]

#df_demo_gender = df_demo_gender[!df_demo_gender$responseNo==7,]
df_demo_gender_responses=df_demo_gender[!df_demo_gender$checked==0,]
########

# Age first: 

# check sample sizes, make sure they deviate not too much:
N_U_age=sum(df_demo_age_responses$group=='U')
N_C_age=sum(df_demo_age_responses$group=='C')
N_D_age=sum(df_demo_age_responses$group=='D')

#aget="Wilcox"
#agetest=uk_wilcox.test(df_demo_age_responses$responseNo[df_demo_age_responses$group=="C"],df_demo_age_responses$responseNo[df_demo_age_responses$group=="U"],paired=FALSE,exact=FALSE)
#ageeffsize=agetest$z_val/(sqrt(nrow(df_demo_age_responses)))
#matchingRes=paste(matchingRes,paste("\n","AgeRaw",sep=""),"",aget,agetest$p.value,ageeffsize,sep = ",")

#MS:kruskal-wallis test
aget="KruskalWallis"
agetest <- kruskal.test(df_demo_age_responses$responseNo ~ df_demo_age_responses$group,data = df_demo_age_responses)

# Gender second:  

# check sample sizes, make sure they deviate not too much:
N_U_gender=sum(df_demo_gender_responses$group=='U')
N_C_gender=sum(df_demo_gender_responses$group=='C')
N_D_gender=sum(df_demo_gender_responses$group=='D')

########
## UK: normality assumption not needed for Kruskal Wallis, so we can indeed skip Shapiro 
# check if sample is normally distributed using shapiro test
#shapiro=shapiro.test(df_demo_gender_responses$responseNo) # if p-value is lower than 0.05, you can conclude that the sample deviates from normality
#if(shapiro$p.value > 0.05){
#  # if it's normal: t-test
#  gent="TTest"
#  gentest=t.test(df_demo_gender_responses$responseNo ~ df_demo_gender_responses$group,alternative="two.sided")
#  geneffsize=cohen.d(df_demo_gender_responses$responseNo ~ df_demo_gender_responses$group)
#} else {
#  gent="Wilcox"
#  gentest=uk_wilcox.test(df_demo_gender_responses$responseNo[df_demo_gender_responses$group=="U"],df_demo_gender_responses$responseNo[df_demo_gender_responses$group=="C"],paired=FALSE,exact=FALSE)
#  geneffsize=gentest$z_val/(sqrt(nrow(df_demo_gender_responses)))
#}
#
#
#matchingRes=paste(matchingRes,paste("\n","GenderRaw",sep=""),shapiro$p.value,gent,gentest$p.value,geneffsize,sep = ",")
## print(gentest)
## print(geneffsize)
########

#MS:kruskal-wallis test
#genkruskal = "Kruskal-Wallis"
#kruskal_result <- kruskal.test(df_demo_gender_responses$responseNo ~ df_demo_gender_responses$group,data = df_demo_gender_responses)
#print(kruskal_result)
########
## UK: in this case, kruskal-wallis is not suitable as it requires at least ordinal data
# gender is nominal data (labels that cannot be brought into a sensible order), calling for a chi^2 test
gent="Chi^2"
df_demo_gender_responses$group=as.factor(df_demo_gender_responses$group)
gentest = chisq.test(df_demo_gender_responses$responseNo, df_demo_gender_responses$group)

# if the chi^2 test is significant, it would mean that there is an association between group and gender
# if it's not, we can assume that both are independent
########
```

We acquired data from `r length(unique(df_demo$userId))` participants, with `r length(unique(df_demo$userId[df_demo$group=="C"]))` users in the control group (`r length(unique(df_demo$userId[df_demo$group=="C" & df_demo$item=="gender" & df_demo$checked==1 & df_demo$responseNo==1]))` female, `r length(unique(df_demo$userId[df_demo$group=="C" & df_demo$item=="gender" & df_demo$checked==1 & df_demo$responseNo==2]))` male, UK: median age group is 18-24y), 

and `r length(unique(df_demo$userId[df_demo$group=="U"]))` users in the UFCE group (`r length(unique(df_demo$userId[df_demo$group=="U" & df_demo$item=="gender" & df_demo$checked==1 & df_demo$responseNo==1]))` female, `r length(unique(df_demo$userId[df_demo$group=="U" & df_demo$item=="gender" & df_demo$checked==1 & df_demo$responseNo==2]))` male, UK: median age group is 25-34y).

and `r length(unique(df_demo$userId[df_demo$group=="D"]))` users in the DiCE explanation group (`r length(unique(df_demo$userId[df_demo$group=="D" & df_demo$item=="gender" & df_demo$checked==1 & df_demo$responseNo==1]))` female, `r length(unique(df_demo$userId[df_demo$group=="D" & df_demo$item=="gender" & df_demo$checked==1 & df_demo$responseNo==2]))` male, UK: median age group is 18-24y)

The analysis showed for *Age*:

* We have age information for `r N_U_age` users in the UFCE explanation, `r N_D_age` users in the DiCE explanation and `r N_C_age` users in the control group.

* Is there a significant difference in terms of age between the groups? We compared ages of users in explanation condition and users in the control condition using a `r aget` test. This showed: chi-squared=`r agetest$statistic `, p=`r agetest$p.value `, df = `r agetest$parameter `
  
The analysis showed for *Gender*:

* We have gender information for `r N_U_gender` users in the UFCE, `r N_D_gender` users in the DiCE and `r N_C_gender` users in the control group.

* Is there a significant difference in terms of gender between the groups? We compared gender distribution for users in explanation condition and users in the control condition using a `r gent` test. This showed: chi-squared (x^2)=`r gentest$statistic `, p=`r gentest$p.value `, df = `r gentest$parameter `.
`

## Quality criteria

Before going into the hypotheses, we should apply some quality criteria to our data. Sub-quality data should be removed. The following subsections take care of such cases.

### Identify "straight-liners" in survey part

Identify users who always give very uniform answers in the survey part.

Aim: identify IDs of users "straight-lining", i.e. giving only responses with either positive or negative valence.

```{r echo=FALSE, warning=FALSE, fig.height = 4, fig.width = 4.5}
# set to data table

dt_survey=setDT(df_survey,key=c("userId"))
# get checked values for items 3-20 (8 is attention)
straightlineSurvey_data=dt_survey[ checked == 1 & itemNo > 2 &  itemNo < 20 & !itemNo==8 & !itemNo==5] 

######
# UK COMMENT: if these analysis would have shown straightlining cases, this would have needed to be inspected closer:
# like this the code omits itemNo=5 also for experimental participants...
######

straightlineSurvey_data$valence=ifelse(straightlineSurvey_data$responseNo>3,"pos","neg")
straightlineSurvey_data$valence[straightlineSurvey_data$responseNo==3 | straightlineSurvey_data$responseNo==6]="neut"

# identify users that answered only using positive / negative / neutral valence
straightlinersSurvey_IDs=straightlineSurvey_data[,list(mismatchValenceSurveyItems=length(unique(valence))>1),keyby=.(userId)]

# keep only users without "mismatchSurveyItems" (no mismatch = uniform answers)
straightlinersSurvey_IDs=straightlinersSurvey_IDs[!straightlinersSurvey_IDs$mismatchValenceSurveyItems]
straightlinersSurvey_IDs=as.character(straightlinersSurvey_IDs$userId)
df_survey[df_survey$userId %in% straightlinersSurvey_IDs & checked==1,]

# Second attention check: did users detect the "red hering" question (item 7 and 5); also consider removing those who did not!

# for control group the total survey items are 8 (item 5 is attention item)
# set to data table
dt_survey_C=setDT(df_survey,key=c("userId"))
attentionFailSurvey_C = dt_survey_C[ checked == 1 & itemNo == 5 & group=='C' & !responseNo==6 ]
attentionFailSurvey_IDs_C=attentionFailSurvey_C$userId

# for Experimental groups the total survey items are 20 (item 7 is attention item)
# set to data table
dt_survey_E=setDT(df_survey,key=c("userId"))
attentionFailSurvey_E = dt_survey_E[ checked == 1 & itemNo == 8 & !group=='C' & !responseNo==6 ]
attentionFailSurvey_IDs_E=attentionFailSurvey_E$userId
attentionFailSurvey_IDs_U=attentionFailSurvey_E$userId[attentionFailSurvey_E$group=='U']
attentionFailSurvey_IDs_D=attentionFailSurvey_E$userId[attentionFailSurvey_E$group=='D']
print(attentionFailSurvey_IDs_E)

# look at survey responses of survey-straightliners:
#df_survey[df_survey$userId %in% attentionFailSurvey_IDs_E & checked==1,]


```
### Remove data from problematic users

As we have identified users that seem to have dodgy data, we want to remove them.

```{r echo=FALSE, warning=FALSE, fig.height = 4, fig.width = 4.5}

# remove survey straightliners
# straightlinersSurvey_IDs_clean=straightlinersSurvey_IDs[!straightlinersSurvey_IDs %in% c(attentionFailSurvey_IDs_E, attentionFailSurvey_IDs_C) ]
# straightlinersSurvey_IDs_clean=df_survey[!straightlinersSurvey_IDs %in% c(attentionFailSurvey_IDs_E, attentionFailSurvey_IDs_C) ]

# remove survey straightliners
df_perf=subset(df_perf, ! userId %in% straightlinersSurvey_IDs)
df_rt=subset(df_rt, ! userId %in% straightlinersSurvey_IDs)
df_survey=subset(df_survey, ! userId %in% straightlinersSurvey_IDs)
df_demo=subset(df_demo, ! userId %in% straightlinersSurvey_IDs)
# print(length(unique(df_rt$userId)))


# remove survey attentionfailures experimental groups
df_perf=subset(df_perf, ! userId %in% attentionFailSurvey_IDs_E)
df_rt=subset(df_rt, ! userId %in% attentionFailSurvey_IDs_E)
df_survey=subset(df_survey, ! userId %in% attentionFailSurvey_IDs_E)
df_demo=subset(df_demo, ! userId %in% attentionFailSurvey_IDs_E)
# print(length(unique(df_rt$userId)))

# remove survey attentionfailures control
df_perf=subset(df_perf, ! userId %in% attentionFailSurvey_IDs_C)
df_rt=subset(df_rt, ! userId %in% attentionFailSurvey_IDs_C)
df_survey=subset(df_survey, ! userId %in% attentionFailSurvey_IDs_C)
df_demo=subset(df_demo, ! userId %in% attentionFailSurvey_IDs_C)
# print(length(unique(df_rt$userId)))

######
## UK: logic changed, this check is not needed anymore.
# repeat sanity check: Number of users in each df the same?
# the value of 4 would be desireable: all IDs represented in all 4 dfs
#userNo_clean <- data.frame(table(c(as.character(unique(df_perf$userId)), as.character(unique(df_rt$userId)), as.character(unique(df_survey$userId)), as.character(unique(df_demo$userId)))))
#names(userNo_clean) <- c("Names", "Matches")
#length(unique(df_survey$userId))
######
```

So to summarize:

* we remove `r length(straightlinersSurvey_IDs)` users that straightlined in the survey
and 
* we remove `r length(attentionFailSurvey_IDs_C)` from control and `r length(attentionFailSurvey_IDs_E)` from experimental groups (UK: with `r length(attentionFailSurvey_IDs_U)` participants from the UFCE group and `r length(attentionFailSurvey_IDs_D)` participants from the UFCE group) who were NOT attentive for the catch item. 

Finally: How many users do we have in our clean demographic df? `r length(unique(df_demo$userId))`

#### UK: remove 3 more individuals: missing data for 3 participants that are present in the demographics / survey, but missing in the performance .csv
```{r echo=FALSE}

# keeping only those users who filled demographics, meaning they played completely
demo_userIds <- unique(df_demo$userId)

# Here is something off: 3 participant IDs appear in the the demographics but are not found in the  
No_perf_users=demo_userIds[!demo_userIds %in% df_perf$userId]

# A) Filtering df_demo, to only keep records with userIds present in df_perf
df_demo <- df_demo[df_demo$userId %in% df_perf$userId, ]

# B) Filtering df_perf df_rt, and df_survey to keep only records with userIds present in df_demo
df_perf <- df_perf[df_perf$userId %in% demo_userIds, ]
df_survey <- df_survey[df_survey$userId %in% demo_userIds, ]
df_rt <- df_rt[df_rt$userId %in% demo_userIds, ]

# # to view the count of records 
# unique_userIds_df_perf <- df_demo %>%
#                           summarise(unique_userIds = n_distinct(userId))
# print(unique_userIds_df_perf)

# length(unique(df_demo$userId))
# length(unique(df_demo$userId[df_demo$group=="D"]))
# length(unique(df_demo$userId[df_demo$group=="D" & df_demo$item=="gender" & df_demo$checked==1 & df_demo$responseNo==1]))
# length(unique(df_demo$userId[df_demo$group=="D" & df_demo$item=="gender" & df_demo$checked==1 & df_demo$responseNo==2]))

```


```{r echo=FALSE}
########
## UK: remove participants without conclusive gender / age information already for finding the median age group:
userIDs_no_age=df_demo$userId[df_demo$item=="age" & df_demo$responseNo==7 & df_demo$checked==1]
userIDs_no_gender=df_demo$userId[df_demo$item=="gender" & df_demo$responseNo==6 & df_demo$checked==1]

df_demo_age=df_demo[df_demo$item=="age" & !df_demo$userId %in% userIDs_no_age, ]
df_demo_gender=df_demo[df_demo$item=="gender" & !df_demo$userId %in% userIDs_no_gender, ]

# summarize to get overview values of frequencies and percentages
df_demo_age_summary=dplyr::summarise(group_by(df_demo_age, group, item, responseNo),
          SumChecks=sum(checked),
          PercUsersChecked=100*(sum(checked)/length(unique(userId))))

# summarize to get overview values of frequencies and percentages
df_demo_gender_summary=dplyr::summarise(group_by(df_demo_gender, group, item, responseNo),
          SumChecks=sum(checked),
          PercUsersChecked=100*(sum(checked)/length(unique(userId))))

## get age distribution after data cleaning
## summarize to get overview values of frequencies and percentages
#df_demo_age_summary=dplyr::summarise(group_by(df_demo[df_demo$item=="age",], group, item, responseNo),
#          SumChecks=sum(checked),
#          PercUsersChecked=100*(sum(checked)/length(unique(userId))))
########

medianAge_C=cumsum(df_demo_age_summary$SumChecks[df_demo_age_summary$group=="C"])
medianAge_U=cumsum(df_demo_age_summary$SumChecks[df_demo_age_summary$group=="U"])
medianAge_D=cumsum(df_demo_age_summary$SumChecks[df_demo_age_summary$group=="D"])





########
## UK: report median age groups:
# C = 23ppl (without "no answer") --> 12th person --> 1st age band
# U = 20 (without "no answer") --> 10/11th person --> 2nd age band
# D = 25 (without "no answer") --> 13th person --> 1st age band
########
```


### Final, clean dataset

To sum up, in our final data we have `r length(unique(df_demo$userId))` users, with `r length(unique(df_demo$userId[df_demo$group=="C"]))` users in the control group (`r length(unique(df_demo$userId[df_demo$group=="C" & df_demo$item=="gender" & df_demo$checked==1 & df_demo$responseNo==1]))` female, `r length(unique(df_demo$userId[df_demo$group=="C" & df_demo$item=="gender" & df_demo$checked==1 & df_demo$responseNo==2]))` male, UK: median age group is 18-24y), and 
`r length(unique(df_demo$userId[df_demo$group=="U"]))` users in the UFCE group (`r length(unique(df_demo$userId[df_demo$group=="U" & df_demo$item=="gender" & df_demo$checked==1 & df_demo$responseNo==1]))` female, `r length(unique(df_demo$userId[df_demo$group=="U" & df_demo$item=="gender" & df_demo$checked==1 & df_demo$responseNo==2]))` male, UK:median age group is 25-34y), and 
`r length(unique(df_demo$userId[df_demo$group=="D"]))` users in the DiCE group (`r length(unique(df_demo$userId[df_demo$group=="D" & df_demo$item=="gender" & df_demo$checked==1 & df_demo$responseNo==1]))` female, `r length(unique(df_demo$userId[df_demo$group=="D" & df_demo$item=="gender" & df_demo$checked==1 & df_demo$responseNo==2]))` male, UK: median age group is 18-24y).

Re-check: are there still no significant differences in terms of gender / age?

```{r echo=FALSE, warning=FALSE}

# statistical differences between groups?
######
# UK: already done, as above
## count users who 'prefered not to answer'
#N_noAnswer_age=nrow(df_demo_age[df_demo_age$responseNo==7 & df_demo_age$checked==1,])
#N_noAnswer_gender=nrow(df_demo_gender[df_demo_gender$responseNo==7 & df_demo_gender$checked==1,])
## remove 'prefer not to answer' entries
#df_demo_age = df_demo_age[!df_demo_age$responseNo==7,]
df_demo_age_responses=df_demo_age[!df_demo_age$checked==0,]

#df_demo_gender = df_demo_gender[!df_demo_gender$responseNo==7,]
df_demo_gender_responses=df_demo_gender[!df_demo_gender$checked==0,]
########

# Age first: 

# check sample sizes, make sure they deviate not too much:
N_U_age=sum(df_demo_age_responses$group=='U')
N_C_age=sum(df_demo_age_responses$group=='C')
N_D_age=sum(df_demo_age_responses$group=='D')

#aget="Wilcox"
#agetest=uk_wilcox.test(df_demo_age_responses$responseNo[df_demo_age_responses$group=="C"],df_demo_age_responses$responseNo[df_demo_age_responses$group=="U"],paired=FALSE,exact=FALSE)
#ageeffsize=agetest$z_val/(sqrt(nrow(df_demo_age_responses)))

#matchingRes=paste(matchingRes,paste("\n","AgeRaw",sep=""),"",aget,agetest$p.value,ageeffsize,sep = ",")

#MS:kruskal-wallis test
agekruskal = "kruskal-wallis"
kruskal_result <- kruskal.test(df_demo_age_responses$responseNo ~ df_demo_age_responses$group,data = df_demo_age_responses)
print(kruskal_result)

# Gender second: 

# check sample sizes, make sure they deviate not too much:
N_U_gender=sum(df_demo_gender_responses$group=='U')
N_C_gender=sum(df_demo_gender_responses$group=='C')
N_D_gender=sum(df_demo_gender_responses$group=='D')

# check for significant differences - "irrelevant plans" judgements:

########
## UK: normality assumption not needed for Kruskal Wallis, so we can indeed skip Shapiro 
# check if sample is normally distributed using shapiro test
#shapiro=shapiro.test(df_demo_gender_responses$responseNo) # if p-value is lower than 0.05, you can conclude that the sample deviates from normality
#if(shapiro$p.value > 0.05){
#  # if it's normal: t-test
#  gent="TTest"
#  gentest=t.test(df_demo_gender_responses$responseNo ~ df_demo_gender_responses$group,alternative="two.sided")
#  geneffsize=cohen.d(df_demo_gender_responses$responseNo ~ df_demo_gender_responses$group)
#} else {
#  gent="Wilcox"
#  gentest=uk_wilcox.test(df_demo_gender_responses$responseNo[df_demo_gender_responses$group=="U"],df_demo_gender_responses$responseNo[df_demo_gender_responses$group=="C"],paired=FALSE,exact=FALSE)
#  geneffsize=gentest$z_val/(sqrt(nrow(df_demo_gender_responses)))
#}
#matchingRes=paste(matchingRes,paste("\n","GenderRaw",sep=""),shapiro$p.value,gent,gentest$p.value,geneffsize,sep = ",")

#MS:kruskal-wallis test
#genkruskal = "kruskal-wallis"
#kruskal_result <- kruskal.test(df_demo_gender_responses$responseNo ~ df_demo_gender_responses$group,data = df_demo_gender_responses)
#print(kruskal_result)
########
## UK: in this case, kruskal-wallis is not suitable as it requires at least ordinal data
# gender is nominal data (labels that cannot be brought into a sensible order), calling for a chi^2 test
gent="Chi^2"
df_demo_gender_responses$group=as.factor(df_demo_gender_responses$group)
gentest = chisq.test(df_demo_gender_responses$responseNo, df_demo_gender_responses$group)

# if the chi^2 test is significant, it would mean that there is an association between group and gender
# if it's not, we can assume that both are independent
########

```
The analysis showed for *Age*:

* We have age information for `r N_U_age` users in the UFCE explanation, `r N_D_age` users in the DiCE explanation and `r N_C_age` users in the control group.

* Is there a significant difference in terms of age between the groups? We compared ages of users in explanation condition and users in the control condition using a `r agekruskal` test. This showed: chi-squred(x^2)=`r kruskal_result$statistic `, p=`r kruskal_result$p.value `, df = `r kruskal_result$parameter `.
  
The analysis showed for *Gender*:

* We have gender information for `r N_U_gender` users in the UFCE, `r N_D_gender` users in the DiCE and `r N_C_gender` users in the control group.

* Is there a significant difference in terms of gender between the groups? We compared gender distribution for users in explanation condition and users in the control condition using a `r gent` test. This showed: chi-squred(x^2)=`r gentest$statistic `, p=`r gentest$p.value `, df = `r gentest$parameter`.

```{r echo=FALSE, warning=FALSE,fig.height = 4, fig.width = 3.5}

# get only age info
df_demo_age = df_demo[df_demo$item=='age',]
df_demo_gender = df_demo[df_demo$item=='gender',]

# summarize to get overview values of frequencies and percentages
df_demo_age_summary=dplyr::summarise(group_by(df_demo_age, group, item, responseNo),
          SumChecks=sum(checked),
          PercUsersChecked=100*(sum(checked)/length(unique(userId))))

# summarize to get overview values of frequencies and percentages
df_demo_gender_summary=dplyr::summarise(group_by(df_demo_gender, group, item, responseNo),
          SumChecks=sum(checked),
          PercUsersChecked=100*(sum(checked)/length(unique(userId))))

# convert to factor for proper plotting:
df_demo_age_summary$responseNo=as.factor(df_demo_age_summary$responseNo)
df_demo_gender_summary$responseNo=as.factor(df_demo_gender_summary$responseNo)

# AGE: display frequency as raw counts
CovAge_FreqUserResponses = ggplot(data=df_demo_age_summary, aes(x=responseNo,fill = group)) + 
  geom_bar(aes(y = SumChecks),stat="identity",position = position_dodge(preserve = "single"))+
  labs(title="Age of participants (freq. counts)",x="", y = "Frequency of answer")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Ccol,Dcol,Ucol), labels = c("Control", "DiCE", "UFCE"))+
  scale_x_discrete(breaks=1:7, labels=c("18-24y","25-34y","35-44y","45-54y","55-64y","65 and\nover","Prefer not\nto answer"))+
  theme(plot.title = element_text(hjust = 0.5),axis.text.x = element_text(angle = 60,hjust = 0.95))

# AGE: display frequency as percentage
CovAge_PercUserResponses = ggplot(data=df_demo_age_summary, aes(x=responseNo,fill = group)) + 
  geom_bar(aes(y = PercUsersChecked),stat="identity",position = position_dodge(preserve = "single"))+
  labs(title="Age of participants (% of users)",x="", y = "% of users")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Ccol,Dcol,Ucol), labels = c("Control", "DiCE", "UFCE"))+
  scale_x_discrete(breaks=1:7, labels=c("18-24y","25-34y","35-44y","45-54y","55-64y","65 and\nover","Prefer not\nto answer"))+
  theme(plot.title = element_text(hjust = 0.5),axis.text.x = element_text(angle = 60,hjust = 0.95))

# put plots together
figure_CovAgeRaw <- ggarrange(CovAge_FreqUserResponses,CovAge_PercUserResponses,
                    ncol = 1, nrow = 2, align = "v")
# save
ggsave("Figures/CovAgeRaw_distribution.pdf",width = 9, height = 7,)

# show 
figure_CovAgeRaw

# GENDER: display frequency as raw counts
CovGender_FreqUserResponses = ggplot(data=df_demo_gender_summary, aes(x=responseNo,fill = group)) + 
  geom_bar(aes(y = SumChecks),stat="identity",position = position_dodge(preserve = "single"))+
  labs(title="Gender of participants (freq. counts)",x="", y = "Frequency of answer")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Ccol,Dcol,Ucol), labels = c("Control", "DiCE", "UFCE"))+
  scale_x_discrete(breaks=1:6, labels=c("Female","Male","Transgender","Non-binary","Not listed","Prefer not\nto answer"))+
  ylim(0, 40)+
  theme(plot.title = element_text(hjust = 0.5),axis.text.x = element_text(angle = 60,hjust = 0.95))

# GENDER: display frequency as percentage
CovGender_PercUserResponses = ggplot(data=df_demo_gender_summary, aes(x=responseNo,fill = group)) + 
  geom_bar(aes(y = PercUsersChecked),stat="identity",position = position_dodge(preserve = "single"))+
  labs(title="Gender of participants (% of users)",x="", y = "% of users")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Ccol,Dcol,Ucol), labels = c("Control", "DiCE", "UFCE"))+
  scale_x_discrete(breaks=1:6, labels=c("Female","Male","Transgender","Non-binary","Not listed","Prefer not\nto answer"))+
  #ylim(0, 70)+
  theme(plot.title = element_text(hjust = 0.5),axis.text.x = element_text(angle = 60,hjust = 0.95))

# put plots together 
figure_CovGenderRaw <- ggarrange(CovGender_FreqUserResponses,CovGender_PercUserResponses,
                    ncol = 1, nrow = 2, align = "v")
# save
ggsave("Figures/CovGenderRaw_distribution.pdf",width = 9, height = 7,)

# show 
figure_CovGenderRaw
```

# Hypotheses

The main hypothesis is the following: The central inquiry in this user study is whether users experience advantages when provided with CEs (UFCE and DiCE) as compared to users who dont receive CEs during the process of learning and identifying relationships within an unfamiliar dataset while engaging with the Alien nutri-Solver system.

*H1) Enhanced Understanding and task performance*, We anticipate that enhanced user comprehension, facilitated by the provided explanations, will result in more effective cognitive learning. Users will also gain the ability to explicitly recognize relevant and irrelevant input features, indicating an improved capability to discern critical data factors.
Evaluation of cognitive learning involves metrics derived from task performance, including objective scores obtained during the game, as well as self-reported responses in the post-game survey.

That means, 

* H1.1) we expect users can more clearly state which plants were relevant and not for the fitness of Shubs (survey items 1 and 2).
*AND*
* H1.2) The users who recieved CEs and utilised Help button can perform better than the control users in the formulation of nutrient diet for the better fitness of Shubs, leading to higher fitness scores.
*AND*
* H1.3) We can observe a correlation between the different performance levels with the usage of Help.

## H1 Analyses (Understanding/Learning)


### H1.1 Plants relevancy identification

```{r echo=FALSE, warning=FALSE, fig.height = 4.5, fig.width = 4.5}

#survey items 1 and 2 explicitly ask users to state which plants they thought were relevant.
#So what did users tick?

relevantPlants_truth=c(2,4,5)
irrelevantPlants_truth=c(1,3)

#print(df_survey_relevantPlants)

# Descriptive stats
# subset to get only relevant data
df_survey_relevantPlants=df_survey[(df_survey$itemNo==1 | df_survey$itemNo==2),]
# set itemNo and responseNo to factors, too
df_survey_relevantPlants$itemNo=as.factor(df_survey_relevantPlants$itemNo)
df_survey_relevantPlants$responseNo=as.factor(df_survey_relevantPlants$responseNo)

# summary(df_survey_relevantPlants)

# summarize to get overview values of frequencies and percentages
df_survey_relevantPlants_summary=dplyr::summarise(group_by(df_survey_relevantPlants,group,itemNo, responseNo),
          SumChecks=sum(checked),
          PercUsersChecked=100*(sum(checked)/length(unique(userId))))
           #.groups = 'drop')

# rectangle data for figure annotation
rect_df_freq<-data.frame(xmin = c(1.5, 3.5, 4.5, 0.5, 2.5), xmax = c(2.5, 4.5, 5.5, 1.5, 3.5), 
                 ymin = c(0, 0, 0, 0, 0), ymax = c(25, 25, 25, 25, 25), 
                 itemNo = as.character(c(1,1,1,2,2)))

# rectangle data for figure annotation
rect_df_perc<-data.frame(xmin = c(1.5, 3.5, 4.5, 0.5, 2.5), xmax = c(2.5, 4.5, 5.5, 1.5, 3.5), 
                 ymin = c(0, 0, 0, 0, 0), ymax = c(101, 101, 101, 101, 101), 
                 itemNo = as.character(c(1,1,1,2,2)))

# display frequency as raw counts
H1.1_p_FreqUserResponses = ggplot(data=df_survey_relevantPlants_summary, aes(x=responseNo,fill = group)) + 
  geom_bar(aes(y = SumChecks),stat="identity",position = position_dodge(preserve = "single"))+
  facet_wrap(vars(itemNo),nrow = 2, ncol = 1,labeller=as_labeller(c(`1`="What plants are relevant?",`2`="What plants are not relevant?")))+
  labs(title="Judged relevance of plants (freq. counts)",x="Plant number", y = "Frequency of answer")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Ccol,Dcol,Ucol), labels = c("Control", "DiCE", "UFCE"))+
  scale_x_discrete(breaks=1:6, labels=c("1","2","3","4","5","don't know"))+
  scale_y_continuous(limits = c(0,20))+
  geom_rect(aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
  alpha = 0.2,colour ="blue",data = rect_df_freq,inherit.aes = FALSE)+
  theme(plot.title = element_text(hjust = 0.5))

# display frequency as percentage of all per group users (how many % of explanation users picked plant 1?)
H1.1_p_PercUserResponses = ggplot(data=df_survey_relevantPlants_summary, aes(x=responseNo,fill = group)) + 
  geom_bar(aes(y = PercUsersChecked),stat="identity",position = position_dodge(preserve = "single"))+
  facet_wrap(vars(itemNo),nrow = 2, ncol = 1,labeller=as_labeller(c(`1`="What plants are relevant?",`2`="What plants are not relevant?")))+
  labs(title="Judged relevance of plants (% of users)",x="Plant number", y = "% of users")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Ccol,Dcol,Ucol), labels = c("Control", "DiCE", "UFCE"))+
  scale_x_discrete(breaks=1:6, labels=c("1","2","3","4","5","don't know"))+
  scale_y_continuous(limits = c(0,101))+
  geom_rect(aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
  alpha = 0.2,colour ="blue",data = rect_df_perc,inherit.aes = FALSE)+
  theme(plot.title = element_text(hjust = 0.5),legend.title = element_blank(), legend.position="bottom")#,legend.position="none"
#ggsave("./results/H1_plant_identification.pdf",width = 5.5, height = 2.5, dpi = 600)
# put all plots together
H1.1_figure1_UserResponses <- ggarrange(H1.1_p_PercUserResponses, nrow = 1, ncol =1)

# save
ggsave("Figures/H1.1_plant_identification.pdf",width = 5, height = 3,)
H1.1_figure1_UserResponses
```
How to evaluate this statistically? Let's just count the matches between 'judged as relevant' / 'judged as irrelevant' user vectors and the true 'relevant' / 'irrelevant' factors.

```{r echo=FALSE, fig.height = 5, fig.width = 5, fig.align = "center"}

# define vectors with ground truth
relevantPlants_truth_vec=c(0,0,0,0,0)
relevantPlants_truth_vec[relevantPlants_truth]=1

# invert relevantPlants_truth_vec to get irrelevant vector
irrelevantPlants_truth_vec=as.numeric(!relevantPlants_truth_vec)

# go from long to wide format:
df_survey_relevantPlants_wide = spread(df_survey_relevantPlants[df_survey_relevantPlants$itemNo==1,],responseNo,checked)
df_survey_irrelevantPlants_wide = spread(df_survey_relevantPlants[df_survey_relevantPlants$itemNo==2,],responseNo,checked)

# define function to compute sum of matches between input and truth
getMatches <- function(x, truth, output) {
 return(sum(c(x[4],x[5],x[6],x[7],x[8])==truth))
}

# compute matches between participant input and truth
matchesRel=apply(df_survey_relevantPlants_wide,1,getMatches,truth=relevantPlants_truth_vec)
matchesIrrel=apply(df_survey_irrelevantPlants_wide,1,getMatches,truth=irrelevantPlants_truth_vec)
df_survey_relevantPlants_wide=cbind(df_survey_relevantPlants_wide,matches = matchesRel)
df_survey_irrelevantPlants_wide=cbind(df_survey_irrelevantPlants_wide,matches = matchesIrrel)

# plot mean number of matches between groups
# function to compute summary stats (mean, sd, sem)
data_summary <- function(data, varname, groupnames){
  summary_func <- function(x, col){
    c(mean = mean(x[[col]], na.rm=TRUE),
      SEM = sd(x[[col]], na.rm=TRUE),
      sem = sd(x[[col]], na.rm=TRUE)/sqrt(length(x[[col]])))
  }
  data_sum<-ddply(data, groupnames, .fun=summary_func,
                  varname)
  data_sum$itemNo=unique(data$itemNo)
  return(data_sum)
}

# compute summary stats (mean, sd, sem)
df_survey_relevantPlants_summary=data_summary(df_survey_relevantPlants_wide, varname="matches", 
                    groupnames=c("group"))

df_survey_irrelevantPlants_summary=data_summary(df_survey_irrelevantPlants_wide, varname="matches", 
                    groupnames=c("group"))

df_survey_relevantPlants_plot=rbind(df_survey_relevantPlants_summary,df_survey_irrelevantPlants_summary)

# plot means and sems
H1.1_figure2_UserResponseMatches = ggplot(df_survey_relevantPlants_plot, aes(x=group, y=mean, fill=group)) + 
  geom_bar(stat="identity", color="black", 
           position=position_dodge()) +
  geom_errorbar(aes(ymin=mean-sem, ymax=mean+sem), width=.2,
                 position=position_dodge(.9))+
  facet_wrap(vars(itemNo),nrow = 2, ncol = 1,labeller=as_labeller(c(`1`="Which plants are relevant?",`2`="Which plants are not relevant?")))+
  labs(title="Mean no. of matches (judgements vs. truth)",x="Group", y = "Mean number of matches")+
  theme_bw(base_size = 10)+
  scale_y_continuous(expand = c(0,0),limits = c(0,5.5),breaks=c(1:5))+
  scale_fill_manual("Group", values=c(Ccol,Dcol,Ucol), labels = c("Control", "DiCE", "UFCE"))+
  geom_hline(aes(yintercept=5, linetype="Max. no.\nof possible\nmatches"), color = "black", size=0.5)+
  scale_linetype_manual(name = "", values = c(5, 3), 
                      guide = guide_legend(override.aes = list(color = c("black"))))+
  theme(plot.title = element_text(hjust = 0.5),legend.position = "bottom",legend.box="vertical")

# save
# ggsave("Figures/H1.1_UserResponseMatches.pdf",width = 5, height = 3,)

# show plot
# print("Mean number of matches between user judgements and ground truth for relevant and irrelevant plants:")
# H1.1_figure2_UserResponseMatches

```

#### MS Analysis: several pairwise comparisons

```{r echo=FALSE, fig.height = 5, fig.width = 5, fig.align = "center"}

# check for significant differences - "relevant plans" judgements:
# check if sample is normally distributed using shapiro test
shapiro=shapiro.test(df_survey_relevantPlants_wide$matches) # if p-value is lower than 0.05, you can conclude that the sample deviates from normality
if(shapiro$p.value > 0.05){
  # if it's normal: t-test
  item1t="TTest"
  item1test=t.test(df_survey_relevantPlants_wide$matches ~ df_survey_relevantPlants_wide$group,alternative="two.sided")
  item1effsize=cohen.d(df_survey_relevantPlants_wide$matches ~ df_survey_relevantPlants_wide$group)
} else {
  item1t_uc="Wilcox"
  item1test_uc=uk_wilcox.test(df_survey_relevantPlants_wide$matches[df_survey_relevantPlants_wide$group=="U"],df_survey_relevantPlants_wide$matches[df_survey_relevantPlants_wide$group=="C"],paired=FALSE,exact=FALSE)
  item1effsize_uc=item1test_uc$z_val/(sqrt(nrow(df_survey_relevantPlants_wide)))
  item1t_dc="Wilcox"
  item1test_dc=uk_wilcox.test(df_survey_relevantPlants_wide$matches[df_survey_relevantPlants_wide$group=="D"],df_survey_relevantPlants_wide$matches[df_survey_relevantPlants_wide$group=="C"],paired=FALSE,exact=FALSE)
  item1effsize_dc=item1test_dc$z_val/(sqrt(nrow(df_survey_relevantPlants_wide)))
  item1t_ud="Wilcox"
  item1test_ud=uk_wilcox.test(df_survey_relevantPlants_wide$matches[df_survey_relevantPlants_wide$group=="U"],df_survey_relevantPlants_wide$matches[df_survey_relevantPlants_wide$group=="D"],paired=FALSE,exact=FALSE)
  item1effsize_ud=item1test_ud$z_val/(sqrt(nrow(df_survey_relevantPlants_wide)))
}
# matchingRes=paste(matchingRes,paste("\n","H1_UserJudgementsRelevPlants",sep=""),shapiro$p.value,item1t,item1test$p.value,item1effsize,sep = ",")
# matchingRes_uc=paste(matchingRes_uc,paste("\n","H1_UserJudgementsRelevPlants",sep=""),shapiro$p.value,item1t_uc,item1test_uc$p.value,item1effsize_uc,sep = ",")
# matchingRes_dc=paste(matchingRes_dc,paste("\n","H1_UserJudgementsRelevPlants",sep=""),shapiro$p.value,item1t_dc,item1test_dc$p.value,item1effsize_dc,sep = ",")

# check for significant differences - "irrelevant plans" judgements:
# check if sample is normally distributed using shapiro test
shapiro=shapiro.test(df_survey_irrelevantPlants_wide$matches) # if p-value is lower than 0.05, you can conclude that the sample deviates from normality
if(shapiro$p.value > 0.05){
  # if it's normal: t-test
  item2t="TTest"
  item2test=t.test(df_survey_irrelevantPlants_wide$matches ~ df_survey_irrelevantPlants_wide$group,alternative="two.sided")
  item2effsize=cohen.d(df_survey_irrelevantPlants_wide$matches ~ df_survey_irrelevantPlants_wide$group)
} else {
  item2t_uc="Wilcox"
  item2test_uc=uk_wilcox.test(df_survey_irrelevantPlants_wide$matches[df_survey_irrelevantPlants_wide$group=="U"],df_survey_irrelevantPlants_wide$matches[df_survey_irrelevantPlants_wide$group=="C"],paired=FALSE,exact=FALSE)
  item2effsize_uc=item2test_uc$z_val/(sqrt(nrow(df_survey_irrelevantPlants_wide)))
  item2t_dc="Wilcox"
  item2test_dc=uk_wilcox.test(df_survey_irrelevantPlants_wide$matches[df_survey_irrelevantPlants_wide$group=="D"],df_survey_irrelevantPlants_wide$matches[df_survey_irrelevantPlants_wide$group=="C"],paired=FALSE,exact=FALSE)
  item2effsize_dc=item2test_dc$z_val/(sqrt(nrow(df_survey_irrelevantPlants_wide)))
  item2t_ud="Wilcox"
  item2test_ud=uk_wilcox.test(df_survey_irrelevantPlants_wide$matches[df_survey_irrelevantPlants_wide$group=="U"],df_survey_irrelevantPlants_wide$matches[df_survey_irrelevantPlants_wide$group=="D"],paired=FALSE,exact=FALSE)
  item2effsize_ud=item2test_ud$z_val/(sqrt(nrow(df_survey_irrelevantPlants_wide)))
}

# matchingRes=paste(matchingRes,paste("\n","H1_UserJudgementsIrrelevPlants",sep=""),shapiro$p.value,item2t,item2test$p.value,item2effsize,sep = ",")

# matchingRes_uc=paste(matchingRes_uc,paste("\n","H1_UserJudgementsIrrelevPlants",sep=""),shapiro$p.value,item2t_uc,item2test_uc$p.value,item2effsize_uc,sep = ",")
# 
# matchingRes_dc=paste(matchingRes_dc,paste("\n","H1_UserJudgementsIrrelevPlants",sep=""),shapiro$p.value,item2t_dc,item2test_dc$p.value,item2effsize_dc,sep = ",")

# # print to see stats
# print("statistics here (U, p-value, r).")
# item2test_uc$statistic# U
# item2test_uc$p.value # p
# item2effsize_uc # r

```
The analysis revealed:

* Is there a significant difference in terms of matches between plants judged as relevant and ground truth?

We performed pairwise comparison (UFCE vs Control, and, DiCE vs Control, and UFCE vs Control)

We compared number of matches for users in UFCE condition (M = `r df_survey_relevantPlants_summary$mean[df_survey_relevantPlants_summary$group=="U"]`, SEM = `r df_survey_relevantPlants_summary$sem[df_survey_relevantPlants_summary$group=="U"]`) and users in the Control condition (M = `r df_survey_relevantPlants_summary$mean[df_survey_relevantPlants_summary$group=="C"]`, SEM = `r df_survey_relevantPlants_summary$sem[df_survey_relevantPlants_summary$group=="C"]`) using a `r item1t_uc` test. This showed

  + for wilcoxon test: U=`r item1test_uc$statistic `, p=`r item1test_uc$p.value `, r = `r item1effsize_uc `
  + So YES! People receiving explanations could better identify relevant features.

Then,
We compared number of matches for users in UFCE condition (M = `r df_survey_relevantPlants_summary$mean[df_survey_relevantPlants_summary$group=="U"]`, SEM = `r df_survey_relevantPlants_summary$sem[df_survey_relevantPlants_summary$group=="U"]`) and users in the DiCE condition (M = `r df_survey_relevantPlants_summary$mean[df_survey_relevantPlants_summary$group=="D"]`, SEM = `r df_survey_relevantPlants_summary$sem[df_survey_relevantPlants_summary$group=="D"]`) using a `r item1t_ud` test. This showed

  + for wilcoxon test: U=`r item1test_ud$statistic `, p=`r item1test_ud$p.value `, r = `r item1effsize_ud `
  + Almost similar behaviour of People receiving explanations from UFCE and DiCE to better identify relevant features.

* Is there a significant difference in terms of matches between plants judged as irrelevant and ground truth?: 
Again, We performed pairwise comparison (UFCE vs Control, and, DiCE vs Control, and UFCE vs Control)

We compared number of matches for users in UFCE condition (M = `r df_survey_irrelevantPlants_summary$mean[df_survey_irrelevantPlants_summary$group=="U"]`, SEM = `r df_survey_irrelevantPlants_summary$sem[df_survey_irrelevantPlants_summary$group=="U"]`) and users in the control condition (M = `r df_survey_irrelevantPlants_summary$mean[df_survey_irrelevantPlants_summary$group=="C"]`, SEM = `r df_survey_irrelevantPlants_summary$sem[df_survey_irrelevantPlants_summary$group=="C"]`) using a `r item2t_uc` test. This showed

  + for wilcoxon test: U=`r item2test_uc$statistic `, p=`r item2test_uc$p.value `, r = `r item2effsize_uc `
  + So YES! People receiving explanations could better identify irrelevant features.

Then, 
We compared number of matches for users in UFCE condition (M = `r df_survey_irrelevantPlants_summary$mean[df_survey_irrelevantPlants_summary$group=="U"]`, SEM = `r df_survey_irrelevantPlants_summary$sem[df_survey_irrelevantPlants_summary$group=="U"]`) and users in the DiCE condition (M = `r df_survey_irrelevantPlants_summary$mean[df_survey_irrelevantPlants_summary$group=="D"]`, SEM = `r df_survey_irrelevantPlants_summary$sem[df_survey_irrelevantPlants_summary$group=="D"]`) using a `r item2t_ud` test. This showed

  + for wilcoxon test: U=`r item2test_ud$statistic `, p=`r item2test_ud$p.value `, r = `r item2effsize_ud `
  + Almost similar behaviour of People receiving explanations from UFCE and DiCE to better identify irrelevant features.

```{r echo=FALSE, fig.height = 4.5, fig.width = 4.5, fig.align = "center"}
# Add significance notation to plot:

H1.1_figure2_UserResponseMatches_anno = ggplot(df_survey_relevantPlants_plot, aes(x=group, y=mean, fill=group)) + 
  geom_bar(stat="identity", color="black", 
           position=position_dodge()) +
  geom_errorbar(aes(ymin=mean-sem, ymax=mean+sem), width=.2,
                 position=position_dodge(.9))+
  facet_wrap(vars(itemNo),nrow = 2, ncol = 1,labeller=as_labeller(c(`1`="Which plants are relevant?",`2`="Which plants are not relevant?")))+
  labs(title="Mean no. of matches (judgements vs. truth)",x="Group", y = "Mean number of matches")+
  theme_bw(base_size = 10)+
  scale_y_continuous(expand = c(0,0),limits = c(0,5.5),breaks=c(1:5))+
  scale_fill_manual("Group", values=c(Ccol,Dcol,Ucol), labels = c("Control", "DiCE", "UFCE"))+
  geom_hline(aes(yintercept=5, linetype="Max. no.\nof possible\nmatches"), color = "black", size=0.5)+
  scale_linetype_manual(name = "", values = c(5, 3), 
                      guide = guide_legend(override.aes = list(color = c("black"))))+
  theme(plot.title = element_text(hjust = 0.5),legend.position = "bottom",axis.ticks.x=element_blank(),axis.text.x=element_blank())+
  geom_segment(aes(x = 1, y = 2.75, xend = 1, yend = 4),colour = "black", size=0.2) +
  geom_segment(aes(x = 2, y = 3.5, xend = 2, yend = 4),colour = "black", size=0.2) +
  geom_segment(aes(x = 1, y = 4, xend = 2, yend = 4),colour = "black", size=0.2) +
  geom_text(x = 1.5,  y = 4.25, label = "**", colour = "black")

# save
ggsave("Figures/H1.1_UserResponseMatches_anno.pdf",width = 5, height = 3,)

# show
H1.1_figure2_UserResponseMatches_anno

```

#### UK suggested analysis: one main test with posthoc tests instead of pairwise comparisons

```{r echo=FALSE, fig.height = 4.5, fig.width = 4.5, fig.align = "center"}

# first of all, the data visualization confirmed that ppl gave consistent answers, so we can safely compute a composiste score for both to reduced the number of comparisons and retain statistical power.

# combine scores to new measure:
df_survey_relevantPlants_combined=data.frame(userId=df_survey_relevantPlants_wide$userId, group=df_survey_relevantPlants_wide$group, matches=df_survey_relevantPlants_wide$matches+df_survey_irrelevantPlants_wide$matches)

# setting up the non-parametric alternative to an ANOVA: Kruskal-Wallis: 
Krusal_plant_relevance=kruskal.test(matches ~ group, data = df_survey_relevantPlants_combined)
Krusal_plant_relevance_effsize=kruskal_effsize(matches ~ group, data = df_survey_relevantPlants_combined)

# posthoc Dunn's test:
PostDunn_plant_relevance=dunnTest(matches ~ group, data = df_survey_relevantPlants_combined, method="bonferroni")


## last, make an annotated figure for this result:
# compute summary stats (mean, sd, sem)
df_survey_relevantPlants_combined_summary=data_summary(df_survey_relevantPlants_combined, varname="matches", 
                    groupnames=c("group"))

# plot means and sems
H1.1_figure2_UserResponseMatches_combined = ggplot(df_survey_relevantPlants_combined_summary, aes(x=group, y=mean, fill=group)) + 
  geom_bar(stat="identity", color="black", 
           position=position_dodge()) +
  geom_errorbar(aes(ymin=mean-sem, ymax=mean+sem), width=.2,
                 position=position_dodge(.9))+
  labs(title="Mean no. of matches (judgements vs. truth)",x="Group", y = "Mean number of matches")+
  theme_bw(base_size = 10)+
  scale_y_continuous(expand = c(0,0),limits = c(0,10.5),breaks=c(1:10))+
  scale_fill_manual("Group", values=c(Ccol,Dcol,Ucol), labels = c("Control","DiCE","UFCE"))+
  geom_hline(aes(yintercept=10, linetype="Max. no.\nof possible\nmatches"), color = "black", size=0.5)+
  scale_linetype_manual(name = "", values = c(5, 3), 
                      guide = guide_legend(override.aes = list(color = c("black"))))+
  theme(plot.title = element_text(hjust = 0.5),legend.position = "bottom",legend.box="vertical")

# Add significance notation to plot:

H1.1_figure2_UserResponseMatches_combined_anno = H1.1_figure2_UserResponseMatches_combined+
  theme(plot.title = element_text(hjust = 0.5),legend.position = "bottom",axis.ticks.x=element_blank(),axis.text.x=element_blank())+
  # first set of asterisk
  geom_segment(aes(x = 1, y = 5.5, xend = 1, yend = 8),colour = "black", size=0.2) +
  geom_segment(aes(x = 2, y = 7, xend = 2, yend = 8),colour = "black", size=0.2) +
  geom_segment(aes(x = 1, y = 8, xend = 2, yend = 8),colour = "black", size=0.2) +
  geom_text(x = 1.5,  y = 8.25, label = "*", colour = "black")+
  # second asterisk
  geom_segment(aes(x = 1, y = 8.25, xend = 1, yend = 9),colour = "black", size=0.2) +
  geom_segment(aes(x = 3, y = 7, xend = 3, yend = 9),colour = "black", size=0.2) +
  geom_segment(aes(x = 1, y = 9, xend = 3, yend = 9),colour = "black", size=0.2) +
  geom_text(x = 2,  y = 9.25, label = "*", colour = "black")
  

# save
ggsave("Figures/H1.1_UserResponseMatches_COMBINED_anno.pdf",width = 5, height = 3,)

# show
H1.1_figure2_UserResponseMatches_combined_anno

```

The analysis revealed:

* Is there a significant difference in terms of matches between plants judged as relevant or not and ground truth?

We performed a non-parametric Kruskal-Wallis test to investigate the main group effect, followed by Dunn's Test as posthoc evaluation, Bonferroni-corrected for multiple comparisons.

* This showed: chi-squared=`r Krusal_plant_relevance$statistic `, p=`r Krusal_plant_relevance$p.value `, df = `r Krusal_plant_relevance$parameter`, effect size eta-squared=`r Krusal_plant_relevance_effsize$effsize`.

Posthoc Dunn's Test revealed a significant difference for `r PostDunn_plant_relevance$res$Comparison[1]` (Z=`r PostDunn_plant_relevance$res$Z[1]`, adjusted p=`r PostDunn_plant_relevance$res$P.adj[1]`),
for `r PostDunn_plant_relevance$res$Comparison[2]` (Z=`r PostDunn_plant_relevance$res$Z[2]`,adjusted p=`r PostDunn_plant_relevance$res$P.adj[2]`),
but not between UFCE and DiCE (`r PostDunn_plant_relevance$res$Comparison[3]`,Z=`r PostDunn_plant_relevance$res$Z[3]`,adjusted p=`r PostDunn_plant_relevance$res$P.adj[3]`).

  + So YES! People receiving explanations could better identify relevant features compared to people receiving no explanations.

### H1.2 Fitness scores

```{r echo=FALSE, warning=FALSE}
 # we assign the scores in the user data based on the newPred values

# Use dplyr to group by userId and PlanetNo, and then assign an incremental attemptNo
df_perf <- df_perf %>%
  group_by(userId, planetNo) %>%
  dplyr::mutate(attemptNo = row_number())

#######
## UK: code computing fitness scores massively simplified

# computing and assigning fitness scores for different users
df_perf <- df_perf %>%
  arrange(userId) %>%
  group_by(userId) %>%
  dplyr::mutate(fitness_score = cumsum(newPred == 1) * 5)

# UK: get those rows with maximal number of attempts per planet per user
df_perf_finAttempt=df_perf
# UK: make factor out of userId for easier sorting
df_perf_finAttempt=df_perf_finAttempt%>% group_by(userId,planetNo) %>% top_n(1, attemptNo)
# UK: list cases where there were less than 3 attempts on planet 3 without newPred=1
#probs=as.data.frame(df_perf_finAttempt[df_perf_finAttempt$planetNo==3 & df_perf_finAttempt$attemptNo<3 & df_perf_finAttempt$newPred==0,])

# make smaller df to check if score assignment is correct
#B=data.frame(ID=df_perf_finAttempt$userId,group=df_perf_finAttempt$group,score=df_perf_finAttempt$fitness_score,predict=df_perf_finAttempt$newPred,attempt=df_perf_finAttempt$attemptNo,planet=df_perf_finAttempt$planetNo)

```

#### H1.2 MS: Cumulative fitness scores(?)

```{r echo=FALSE, warning=FALSE}

#####
## UK:
# ADDED 0 as sanity check (do the numbers add up?), they weirdly don't...
#####

summary_table <- df_perf %>%
   group_by(group, userId, attemptNo) %>%
   summarize(
     achieved_15 = sum(fitness_score == 15),
     achieved_10 = sum(fitness_score == 10),
     achieved_5 = sum(fitness_score == 5)#,
     #achieved_0 = sum(fitness_score == 0)
   ) %>%
   group_by(group) %>%
   summarise(
     #Score_0 = mean(achieved_0 > 0) * 100,
     Score_5 = mean(achieved_5 > 0) * 100,
     Score_10 = mean(achieved_10 > 0) * 100,
     Score_15 = mean(achieved_15 > 0) * 100
   )
# Display the summary table
 # print(summary_table)

# plotting
summary_table_long <- tidyr::pivot_longer(summary_table,
                                          cols = c(Score_5, Score_10, Score_15),
                                          names_to = "Achievement_Level",
                                          values_to = "Percentage")

summary_table_long$Achievement_Level <- factor(summary_table_long$Achievement_Level,
                                               levels = c("Score_5", "Score_10", "Score_15"),
                                               ordered = TRUE)

# Plotting
H1.2_fitnessScore = ggplot(summary_table_long, aes(x = Achievement_Level, y = Percentage, color = group, group = group)) +
  geom_line() +
  labs(x = "Score Achievement Level",
       y = "User's Percentage Achieved",
       color = "Group") +
  scale_fill_manual("Group", values=c(Ccol,Dcol,Ucol), labels = c("Control", "DiCE", "UFCE"))+
  theme_minimal()
# H1.2_fitnessScore <- ggarrange(H1.2_fitnessScore)
H1.2_fitnessScore
# save
ggsave("Figures/H1.2_fitnessScore.pdf",width = 5, height = 3,)


```

#### H1.2 UK suggested analysis: Fitness scores

```{r echo=FALSE, warning=FALSE}
# 
# # For a rough look at the data first: plot the individual fitness scores per person on their last attempt per planet:
# spaghetti_data=as.data.frame(df_perf_finAttempt)
# spaghetti_data$userId=as.factor(spaghetti_data$userId)
# spaghetti_data$group=as.factor(spaghetti_data$group)
# spaghetti_C=ggplot(data=spaghetti_data[spaghetti_data$group=="C",],aes(x=planetNo,y=fitness_score,group=userId,color=userId))+ 
#   #geom_point(alpha = 0.5,position=position_jitter(w=0.02, h=0))+
#   geom_line(position=position_jitter(w=0.3, h=0.0))+
#   facet_grid(. ~ userId)+
#   theme(legend.position = "none")
# spaghetti_D=ggplot(data=spaghetti_data[spaghetti_data$group=="D",],aes(x=planetNo,y=fitness_score,group=userId,color=userId))+ 
#   #geom_point(alpha = 0.5,position=position_jitter(w=0.02, h=0))+
#   geom_line(position=position_jitter(w=0.3, h=0.0))+
#   facet_grid(. ~ userId)+
#   theme(legend.position = "none")
# spaghetti_U=ggplot(data=spaghetti_data[spaghetti_data$group=="U",],aes(x=planetNo,y=fitness_score,group=userId,color=userId))+ 
#   #geom_point(alpha = 0.5,position=position_jitter(w=0.02, h=0))+
#   geom_line(position=position_jitter(w=0.3, h=0.0))+
#   facet_grid(. ~ userId)+
#   theme(legend.position = "none")
#spaghetti_ALL=ggplot(data=spaghetti_data,aes(x=planetNo,y=fitness_score,group=userId,color=group))+ 
   #geom_point(alpha = 0.5,position=position_jitter(w=0.02, h=0))+
#   geom_line(position=position_jitter(w=0.3, h=0.0))
  
# Analyse the final fitness scores per group
# get fitness score at final attempt on planet 3:
df_final_fitness=as.data.frame(df_perf_finAttempt[df_perf_finAttempt$planetNo==3,])

# setting up the non-parametric alternative to an ANOVA: Kruskal-Wallis: 
Krusal_final_fitness=kruskal.test(fitness_score ~ group, data = df_final_fitness)
Krusal_final_fitness_effsize=kruskal_effsize(fitness_score ~ group, data=df_final_fitness)

# posthoc Dunn's test:
PostDunn_final_fitness=dunnTest(fitness_score ~ group, data = df_final_fitness, method="bonferroni")

## last, make an annotated figure for this result:
# compute summary stats (mean, sd, sem)
df_final_fitness_summary=data_summary(df_final_fitness, varname="fitness_score", groupnames=c("group"))

H1.2_fitnessScore_perGroup = ggplot(df_final_fitness_summary, aes(x=group, y=mean, fill=group)) + 
  geom_bar(stat="identity", color="black", 
           position=position_dodge()) +
  geom_errorbar(aes(ymin=mean-sem, ymax=mean+sem), width=.2,
                 position=position_dodge(.9))+
  labs(title="Mean final fitness score per group",x="Group", y = "Mean final fitness score")+
  theme_bw(base_size = 10)+
  scale_y_continuous(expand = c(0,0),limits = c(0,15.5),breaks=c(1:15))+
  scale_fill_manual("Group", values=c(Ccol,Dcol,Ucol), labels = c("Control", "DiCE","UFCE"))+
  geom_hline(aes(yintercept=15, linetype="Max. fitness\nscore possible"), color = "black", size=0.5)+
  scale_linetype_manual(name = "", values = c(5, 3), 
                      guide = guide_legend(override.aes = list(color = c("black"))))+
  theme(plot.title = element_text(hjust = 0.5),legend.position = "bottom",legend.box="vertical")

# Add significance notation to plot:
H1.2_fitnessScore_perGroup_anno = 
  H1.2_fitnessScore_perGroup+
  theme(plot.title = element_text(hjust = 0.5),legend.position = "bottom",axis.ticks.x=element_blank(),axis.text.x=element_blank())+
  # first asterisk: D-U
  geom_segment(aes(x = 2, y = 9, xend = 2, yend = 13.5),colour = "black", size=0.2) +
  geom_segment(aes(x = 3, y = 13, xend = 3, yend = 13.5),colour = "black", size=0.2) +
  geom_segment(aes(x = 2, y = 13.5, xend = 3, yend = 13.5),colour = "black", size=0.2) +
  geom_text(x = 2.5,  y = 13.75, label = "*", colour = "black")+
  # second asterisk: C-U
  geom_segment(aes(x = 1, y = 5.5, xend = 1, yend = 14.25),colour = "black", size=0.2) +
  geom_segment(aes(x = 3, y = 13.75, xend = 3, yend = 14.25),colour = "black", size=0.2) +
  geom_segment(aes(x = 1, y = 14.25, xend = 3, yend = 14.25),colour = "black", size=0.2) +
  geom_text(x = 2,  y = 14.5, label = "***", colour = "black")

# save
ggsave("Figures/H1.2_MeanFinalFitnessPerGroup_anno.pdf",width = 5, height = 3,)

# show
H1.2_fitnessScore_perGroup_anno

```

The analysis revealed:

* Is there a significant difference in terms of final fitness score obtained per group?

We performed a non-parametric Kruskal-Wallis test to investigate the main group effect, followed by Dunn's Test as posthoc evaluation, Bonferroni-corrected for multiple comparisons.

* This showed: chi-squared=`r Krusal_final_fitness$statistic `, p=`r Krusal_final_fitness$p.value `, df = `r Krusal_final_fitness$parameter`, effect size eta-squared=`r Krusal_final_fitness_effsize$effsize`.

Posthoc Dunn's Test revealed a significant difference for `r PostDunn_final_fitness$res$Comparison[1]` (Z=`r PostDunn_final_fitness$res$Z[1]`, adjusted p=`r PostDunn_final_fitness$res$P.adj[1]`),
and for `r PostDunn_final_fitness$res$Comparison[2]` (Z=`r PostDunn_final_fitness$res$Z[2]`,adjusted p=`r PostDunn_final_fitness$res$P.adj[2]`),
and for `r PostDunn_final_fitness$res$Comparison[3]` (Z=`r PostDunn_final_fitness$res$Z[3]`,adjusted p=`r PostDunn_final_fitness$res$P.adj[3]`).

  + So YES! People receiving explanation did achieve higher fitness compared to no-explanations controls.
  + BUT ALSO: Participants in the UFCE group massively outperformed participants in the DiCE group. Highly unexpected!!! Why could that be?

### H1.3 Correlations betwen the usage of Help and performance

```{r echo=FALSE, warning=FALSE}
library(dplyr)
library(ggplot2)
library(cowplot)

logH_source = list.files(path = "./ufce", pattern="logHelp.csv",full.names=TRUE)
df_logH_u=read.csv(logH_source,header=TRUE)
df_logH_u=df_logH_u[!duplicated(df_logH_u),]
# adding label of U to distnguish 
df_logH_u$group <- 'U'
logH_source = list.files(path = "./dice", pattern="logHelp.csv",full.names=TRUE)
df_logH_d=read.csv(logH_source,header=TRUE)
df_logH_d=df_logH_d[!duplicated(df_logH_d),]
# adding label of D to distnguish 
df_logH_d$group <- 'D'

# Merge the dataframes
if (identical(colnames(df_logH_u), colnames(df_logH_d))) {
  # Bind the data frames vertically
  df_logH <- rbind(df_logH_u, df_logH_d)
} else {
  # Print an error message if column names don't match
  print("Column names don't match.")
}
# df_logH$U <- NULL

# Compute scores directly from df_perf
summary_table <- df_perf %>%
  # filter(group == "D") %>%
  # group_by(userId, attemptNo) %>%
  group_by(group, userId, attemptNo) %>%
  summarize(
    achieved_15 = sum(fitness_score == 15),
    achieved_10 = sum(fitness_score == 10),
    achieved_5 = sum(fitness_score == 5)
  ) %>%
  # filter(group == "D") %>%
  group_by(group, userId) %>%
  summarise(
    Score_5 = mean(achieved_5 > 0) * 100,
    Score_10 = mean(achieved_10 > 0) * 100,
    Score_15 = mean(achieved_15 > 0) * 100
  )

# Merge with df_logH based on userId
# merged_df <- inner_join(df_logH, summary_table, by = "userId")
merged_df <- inner_join(df_logH, summary_table, by = c("userId", "group"))


# Create separate plots for each score
plots <- lapply(c("Score_5", "Score_10", "Score_15"), function(score) {
  # Plot for the current score
  plot <- ggplot(merged_df, aes(x = help_hits, y = !!sym(score))) +
    geom_point() +
    geom_smooth(method = "lm")
    # labs(title = paste("help_hits ~ ", score),
    #      x = "help_hits",
    #      y = score)

  # Return the plot
  return(plot)
})

# Combine plots into a single plot object
plots_combined <- cowplot::plot_grid(plotlist = plots, ncol = 2)
# plots_combined

# Create plots for each score level with regression lines for both groups
plots_combined <- lapply(c("Score_5", "Score_10", "Score_15"), function(score) {
  # Plot for the current score level with regression lines for both groups
  plot <- ggplot(merged_df, aes(x = help_hits, y = !!sym(score), color = group)) +
    geom_point() +
    geom_smooth(method = "lm", se = TRUE)+
    theme(legend.position = "bottom")
    # labs(title = paste("help_hits ~ ", score),
    #      x = "help_hits",
    #      y = score)

  # Return the plot
  return(plot)
})


# Display the combined plots for each score level with regression lines for both groups
H1.3_corelation <- cowplot::plot_grid(plotlist = plots_combined, ncol = 3)
H1.3_corelation
# save
ggsave("Figures/H1.3_corelation_help_fitnessScore.pdf",width = 6, height = 3,)

```

##### H1.3 UK suggested analysis: Correlations betwen the usage of Help and performance

```{r echo=FALSE, warning=FALSE}
logH_source = list.files(path = "./ufce", pattern="logHelp.csv",full.names=TRUE)
df_logH_u=read.csv(logH_source,header=TRUE)
#df_logH_u=df_logH_u[!duplicated(df_logH_u),]
# adding label of U to distnguish 
df_logH_u$group <- 'U'
logH_source = list.files(path = "./dice", pattern="logHelp.csv",full.names=TRUE)
df_logH_d=read.csv(logH_source,header=TRUE)
#df_logH_d=df_logH_d[!duplicated(df_logH_d),]
# adding label of D to distnguish 
df_logH_d$group <- 'D'

# Merge the dataframes
if (identical(colnames(df_logH_u), colnames(df_logH_d))) {
  # Bind the data frames vertically
  df_logH <- rbind(df_logH_u, df_logH_d)
} else {
  # Print an error message if column names don't match
  print("Column names don't match.")
}

# retain only those userIDs where we have remaining data:
# i.e., filtering df_demo, to only keep records with userIds present in df_perf
df_logH <- df_logH[df_logH$userId %in% df_perf$userId, ]

# resulting in 19 participants from UFCE, and 25 participants from DiCE group

# now compute: total number of help hits per person across planets
df_logH_total=df_logH %>%
  arrange(userId) %>%
  group_by(userId) %>%
  dplyr::mutate(total_help_hits=sum(help_hits))

# drop columns not needed for this analysis, remove duplicates
df_logH_total=subset(df_logH_total, select = -c(planetNo,help_hits,available_budget,ShubHealth))
df_logH_total=df_logH_total[!duplicated(df_logH_total),]

df_logH_total$final_fitness=df_final_fitness$fitness_score[df_final_fitness$userId %in% df_logH_total$userId]

# summarize mean usage of help per group to get a feeling
df_logH_total_summary=data_summary(df_logH_total, varname="total_help_hits", groupnames=c("group"))

# Generate a plot to get a feeling
H1.2_total_help_by_total_fitness=ggplot(data=df_logH_total,aes(x=total_help_hits,y=final_fitness,color=group),group=group,color=group,fill=c(Dcol,Ucol))+
  geom_point()+
  geom_jitter(height = 0.5, width = 0.5)+
  geom_smooth(method = "lm", se = TRUE)+
  labs(title="Total help usage by total fitness",x="Total help usage", y = "Total final fitness")+
  theme_bw(base_size = 10)+
  scale_color_manual(values=c(Dcol,Ucol), labels = c("DiCE","UFCE"))+
  scale_linetype_manual(name = "", values = c(5, 3), 
                      guide = guide_legend(override.aes = list(color = c("black"))))+
  theme(plot.title = element_text(hjust = 0.5),legend.position = "bottom",legend.box="vertical")
```

Overall, the figure emphasizes once again that UFCE users perform stronger than DiCE ppl (regression line of UFCE well above DiCE). However, the slope is the same, so this is rather a main effect of group, unrelated to the help button usage.
Unfortunately, the logged help data seems to be incomplete again (not all participants have an entry for each planet), so I would like to be careful about any (firm) interpretation and also refrain from running stats here.

#### H1.4 Correlation of Decision-making and Time

```{r echo=FALSE, warning=FALSE}
library(ggplot2)

rt_source = list.files(path = "./mergedfiles", pattern="reactionTime.csv",full.names=TRUE)
df_rt=read.csv(rt_source,header=TRUE)
df_rt=df_rt[!duplicated(df_rt),]

# Group the data by 'group' and 'userId', and calculate average time for each screen
overall_avg_time <- df_rt %>%
  group_by(group) %>%
  summarise(avg_time_agreement_screen = mean(`timeAgreementScene`),
            avg_time_start_screen = mean(`timeStartScene`))

overall_avg_time$avg_time_agreement_screen <- overall_avg_time$avg_time_agreement_screen / 1000
overall_avg_time$avg_time_start_screen <- overall_avg_time$avg_time_start_screen / 1000
# average time on agreement and start screens
# print(overall_avg_time)


## average times from planetNo 1 to 3 for configuration screen and decision screen (eventId 5 and 6, resp.)

rt_source_u = list.files(path = "./ufce", pattern="ConfigScreenTime.csv",full.names=TRUE)
rt_source_d = list.files(path = "./dice", pattern="ConfigScreenTime.csv",full.names=TRUE)
rt_source_c = list.files(path = "./control", pattern="ConfigScreenTime.csv",full.names=TRUE)
df_rt_u = read.csv(rt_source_u,header=TRUE)
df_rt_d = read.csv(rt_source_d,header=TRUE)
df_rt_c = read.csv(rt_source_c,header=TRUE)

df_rt_u = df_rt_u[!duplicated(df_rt_u),]
df_rt_d = df_rt_d[!duplicated(df_rt_d),]
df_rt_c = df_rt_c[!duplicated(df_rt_c),]

# Version 1: ALL DATA

# Function to calculate average time by planet for a given event and dataframe
calculate_average_time_by_planet_event <- function(df, label, event) {
  # Filter the dataframe to include only the specified event
  df_filtered <- df %>%
    filter(eventId == event)
  
  # Group the data by 'planetNo' and calculate average time spent on each planet for the specified event
  average_time_by_planet_event <- df_filtered %>%
    group_by(planetNo) %>%
    summarise(avg_time = mean(time))
  
  # Add labels for the dataframe
  average_time_by_planet_event$label <- label
  average_time_by_planet_event$event <- event
  
  # Return the dataframe
  return(average_time_by_planet_event)
}

# List of dataframes with labels
df_list <- list("UFCE" = df_rt_u, "DiCE" = df_rt_d, "Control" = df_rt_c)

# List to store results for each dataframe and event
average_time_by_planet_event_list <- list()

# Calculate average time by planet for each event and dataframe
for (name in names(df_list)) {
  df <- df_list[[name]]
  for (event in c(5, 6)) {
    average_time_by_planet_event_list[[paste(name, "_event", event, sep = "")]] <- calculate_average_time_by_planet_event(df, name, event)
  }
}

# Combine the results
combined_data <- bind_rows(average_time_by_planet_event_list)

# Calculate standard error of the mean (SEM) for each group, event, and planet
sem_data <- combined_data %>%
  group_by(label, event, planetNo) %>%
  summarise(sem = sd(avg_time) / sqrt(n()))

# Merge SEM data with combined_data
combined_data_all <- merge(combined_data, sem_data, by = c("label", "event", "planetNo"))


# Plot combined_data with SEM
H1.4_corelation_time_fitnessScore_ALLDATA = ggplot(combined_data_all, aes(x = planetNo, y = avg_time / 1000, color = label, linetype = factor(event), )) +
  geom_point() +
  geom_line() +
  geom_errorbar(aes(ymin = (avg_time - sem) / 1000, ymax = (avg_time + sem) / 1000), width = 0.1) + # Adjust width as needed
  labs(x = "Planet Number", y = "Average Time (seconds)", color = "Group", linetype = "Event") +
  ggtitle("Average Time on each Planet ALL DATA") +
  scale_color_manual(values = c(Ccol,Dcol,Ucol))+
  theme(legend.position = "bottom")

H1.4_corelation_time_fitnessScore_ALLDATA
# save
ggsave("Figures/H1.4_corelation_time_fitnessScore_ALLDATA.pdf",width = 5, height = 3,)

# Comparison of analyses for different dataframes
comparison <- combined_data_all %>%
  group_by(label, event) %>%
  summarise(avg_time = mean(avg_time))

# # Print the comparison
# print(comparison)


```
```{r echo=FALSE, warning=FALSE, eval = FALSE}
# Perform t-tests between groups
t_test_uc <- t.test(avg_time ~ label, data = combined_data_all,
                    subset = label %in% c("UFCE", "Control"))
t_test_ud <- t.test(avg_time ~ label, data = combined_data_all,
                    subset = label %in% c("UFCE", "DiCE"))
t_test_cd <- t.test(avg_time ~ label, data = combined_data_all,
                    subset = label %in% c("Control", "DiCE"))

# Print the results
print(t_test_uc)
print(t_test_ud)
print(t_test_cd)

```
The Welch Two Sample t-test compared the average times between the "DiCE" and "UFCE" and "UFCE" and "control" groups, etc. The test yielded a t-value of -1.8211 with 5.9063 degrees of freedom, resulting in a p-value of 0.1192. As the p-value exceeds the typical significance level of 0.05, there is insufficient evidence to reject the null hypothesis. Therefore, no statistically significant difference in average times between the groups. The 95% confidence interval for the difference in means (-68850.04, 10225.46) further supports this conclusion, encompassing zero.

##### H1.4 Correlatio time: WiNNER DATA

```{r echo=FALSE, warning=FALSE}
#Version-2: WINNER DATA

# Compute scores directly from df_perf
summary_table <- df_perf %>%
  group_by(group, userId, planetNo) %>%
  summarize(
    achieved_15 = sum(fitness_score == 15),
    achieved_10 = sum(fitness_score == 10),
    achieved_5 = sum(fitness_score == 5)
  ) %>%
  # filter(group == "D") %>%
  group_by(group, userId) %>%
  summarise(
    Score_5 = max(achieved_5 > 0) * 100,
    Score_10 = max(achieved_10 > 0) * 100,
    Score_15 = max(achieved_15 > 0) * 100
  )

# summary_table

# Step 1: Filter original dataframes to include only users who achieved maximum scores
df_rt_u_max <- df_rt_u %>%
  filter(userId %in% summary_table$userId[summary_table$group == "U" & summary_table$Score_15 == 100])
df_rt_d_max <- df_rt_d %>%
  filter(userId %in% summary_table$userId[summary_table$group == "D" & summary_table$Score_15 == 100])
df_rt_c_max <- df_rt_c %>%
  filter(userId %in% summary_table$userId[summary_table$group == "C" & summary_table$Score_5 == 100])

# Step 2: Merge filtered dataframes with df_perf to obtain fitness scores
df_rt_u_max <- merge(df_rt_u_max, df_perf, by = c("userId", "planetNo"))
df_rt_d_max <- merge(df_rt_d_max, df_perf, by = c("userId", "planetNo"))
df_rt_c_max <- merge(df_rt_c_max, df_perf, by = c("userId", "planetNo"))

# Step 3: Proceed with the existing analysis code using the filtered and merged dataframes
# Function to calculate average time by planet for a given event and dataframe
calculate_average_time_by_planet_event <- function(df, label, event) {
  # Filter the dataframe to include only the specified event
  df_filtered <- df %>%
    filter(eventId == event)
  
  # Group the data by 'planetNo' and calculate average time spent on each planet for the specified event
  average_time_by_planet_event <- df_filtered %>%
    group_by(planetNo) %>%
    summarise(avg_time = mean(time))
  
  # Add labels for the dataframe
  average_time_by_planet_event$label <- label
  average_time_by_planet_event$event <- event
  
  # Return the dataframe
  return(average_time_by_planet_event)
}

# List of dataframes with labels
df_list <- list("UFCE" = df_rt_u_max, "DiCE" = df_rt_d_max, "Control" = df_rt_c_max)

# List to store results for each dataframe and event
average_time_by_planet_event_list <- list()

# Calculate average time by planet for each event and dataframe
for (name in names(df_list)) {
  df <- df_list[[name]]
  for (event in c(5, 6)) {
    average_time_by_planet_event_list[[paste(name, "_event", event, sep = "")]] <- calculate_average_time_by_planet_event(df, name, event)
  }
}

# Combine the results
combined_data <- bind_rows(average_time_by_planet_event_list)

# Calculate standard error of the mean (SEM) for each group, event, and planet
sem_data <- combined_data %>%
  group_by(label, event, planetNo) %>%
  summarise(sem = sd(avg_time) / sqrt(n()))

# Merge SEM data with combined_data
combined_data_winner <- merge(combined_data, sem_data, by = c("label", "event", "planetNo"))

# combined_data_winner

# Plot combined_data with SEM
H1.4_corelation_time_fitnessScore_WinnerDATA = ggplot(combined_data_winner, aes(x = planetNo, y = avg_time / 1000, color = label, linetype = factor(event))) +
  geom_point() +
  geom_line() +
  geom_errorbar(aes(ymin = (avg_time - sem) / 1000, ymax = (avg_time + sem) / 1000), width = 0.1) + # Adjust width as needed
  labs(x = "Planet Number", y = "Average Time (seconds)", color = "Group", linetype = "Event") +
  ggtitle("Average Time on each Planet for WINNER DATA") +
  scale_color_manual(values = c(Ccol,Dcol,Ucol))+
  theme(legend.position = "bottom")

H1.4_corelation_time_fitnessScore_WinnerDATA
# save
ggsave("Figures/H1.4_corelation_time_fitnessScore_WinnerDATA.pdf",width = 5, height = 3,)

```
##### H1.4 final plot (plots)
```{r echo=FALSE, fig.height = 3, fig.width = 5, fig.align = "center"}
# put all three H1.4 figures to one for publication
library(ggplot2)
library(ggpubr)


# remove individual titles before putting all plots together:
H1.4_corelation_time_fitnessScore_ALLDATA$labels$title=c()
H1.4_corelation_time_fitnessScore_WinnerDATA$labels$title=c()


arranged_plots <- ggarrange(H1.4_corelation_time_fitnessScore_ALLDATA + theme(legend.position = "right"), 
                            H1.4_corelation_time_fitnessScore_WinnerDATA + theme(legend.position = "right"),
                            ncol = 2, common.legend = TRUE)


H1.4_correlation_all_winner = ggarrange(arranged_plots, ncol = 2, nrow = 2, widths=c(65,5,35),common.legend = TRUE, legend = "bottom")

# save
ggsave("Figures/H1.4_correlation_time_score_final.pdf",width = 7, height = 5) #width = 7, height = 2,

# display big summary figure:
H1.4_correlation_all_winner

```

##### H1.4 UK sugested analysis: Group difference in terms of time needed for decision making?

A correlation approach would probably be interesting if we had a little more data. I also think that the separation into winner / loser given the current data is pretty difficult.
My suggested alternative would again be a more simple group analysis.

```{r echo=FALSE, warning=FALSE}

rt_source = list.files(path = "./mergedfiles", pattern="reactionTime.csv",full.names=TRUE)
df_rt=read.csv(rt_source,header=TRUE)
df_rt=df_rt[!duplicated(df_rt),]

# Group the data by 'group' and 'userId', and calculate average time for each screen
overall_avg_time <- df_rt %>%
  group_by(group) %>%
  summarise(avg_time_agreement_screen = mean(`timeAgreementScene`),
            avg_time_start_screen = mean(`timeStartScene`))

overall_avg_time$avg_time_agreement_screen <- overall_avg_time$avg_time_agreement_screen / 1000
overall_avg_time$avg_time_start_screen <- overall_avg_time$avg_time_start_screen / 1000
# average time on agreement and start screens
# print(overall_avg_time)


## average times from planetNo 1 to 3 for configuration screen and decision screen (eventId 5 and 6, resp.)

rt_source_u = list.files(path = "./ufce", pattern="ConfigScreenTime.csv",full.names=TRUE)
rt_source_d = list.files(path = "./dice", pattern="ConfigScreenTime.csv",full.names=TRUE)
rt_source_c = list.files(path = "./control", pattern="ConfigScreenTime.csv",full.names=TRUE)
df_rt_u = read.csv(rt_source_u,header=TRUE)
df_rt_d = read.csv(rt_source_d,header=TRUE)
df_rt_c = read.csv(rt_source_c,header=TRUE)

df_rt_u = df_rt_u[!duplicated(df_rt_u),]
df_rt_d = df_rt_d[!duplicated(df_rt_d),]
df_rt_c = df_rt_c[!duplicated(df_rt_c),]

df_rt_u$group=rep("U",nrow(df_rt_u))
df_rt_d$group=rep("D",nrow(df_rt_d))
df_rt_c$group=rep("C",nrow(df_rt_c))

# combine into large DF
df_rt=rbind(df_rt_u,df_rt_d,df_rt_c)

# keep only time data from complete participants
df_rt <- df_rt[df_rt$userId %in% df_perf$userId, ]
## good news: RT data from all participants is available!

# make seconds our of ms
df_rt$time=df_rt$time/1000

# generate summary stats
# remember: configuration screen (eventId 5) and decision screen (eventId6)

# calculate stats:
df_rt_summary = data_summary(df_rt,varname="time",groupnames=c("group","eventId")) 

####
## First: time spent on configuration screen (eventId 5)
Krusal_time_config_screen=kruskal.test(time ~ group, data = df_rt[df_rt$eventId==5,])
Krusal_time_config_screen_effsize=kruskal_effsize(time ~ group, data = df_rt[df_rt$eventId==5,])

# posthoc Dunn's test:
PostDunn_time_config_screen=dunnTest(time ~ group, data = df_rt[df_rt$eventId==5,], method="bonferroni")

## last, make an annotated figure for this result:

H1.4_time_config_screen_perGroup = ggplot(df_rt_summary[df_rt_summary$eventId==5,], aes(x=group, y=mean, fill=group)) + 
  geom_bar(stat="identity", color="black", 
           position=position_dodge()) +
  geom_errorbar(aes(ymin=mean-sem, ymax=mean+sem), width=.2,
                 position=position_dodge(.9))+
  labs(title="Mean time on config. screen per group",x="Group", y = "Mean time in s")+
  theme_bw(base_size = 10)+
  scale_y_continuous(expand = c(0,0),limits = c(0,67))+
  scale_fill_manual("Group", values=c(Ccol,Dcol,Ucol), labels = c("Control", "DiCE","UFCE"))+
  theme(plot.title = element_text(hjust = 0.5),legend.position = "bottom",legend.box="vertical")

# Add significance notation to plot:
H1.4_time_config_screen_perGroup_anno = 
  H1.4_time_config_screen_perGroup+
  theme(plot.title = element_text(hjust = 0.5),legend.position = "bottom",axis.ticks.x=element_blank(),axis.text.x=element_blank())+
  # first asterisk: C-D
  geom_segment(aes(x = 1, y = 55, xend = 1, yend = 62),colour = "black", size=0.2) +
  geom_segment(aes(x = 1.95, y = 30, xend = 1.95, yend = 62),colour = "black", size=0.2) +
  geom_segment(aes(x = 1, y = 62, xend = 1.95, yend = 62),colour = "black", size=0.2) +
  geom_text(x = 1.49,  y = 64, label = "**", colour = "black")+
  # second asterisk: D-U
  geom_segment(aes(x = 2.05, y = 30, xend = 2.05, yend = 62),colour = "black", size=0.2) +
  geom_segment(aes(x = 3, y = 59, xend = 3, yend = 62),colour = "black", size=0.2) +
  geom_segment(aes(x = 2.05, y = 62, xend = 3, yend = 62),colour = "black", size=0.2) +
  geom_text(x = 2.51,  y = 64, label = "**", colour = "black")

# save
ggsave("Figures/H1.4_MeanTime_config_screen_PerGroup_anno.pdf",width = 5, height = 3,)

# show
H1.4_time_config_screen_perGroup_anno

### 
## Second: time spent on decision screen (eventId 6)
Krusal_time_decision_screen=kruskal.test(time ~ group, data = df_rt[df_rt$eventId==6,])
Krusal_time_decision_screen_effsize=kruskal_effsize(time ~ group, data = df_rt[df_rt$eventId==6,])

# posthoc Dunn's test:
PostDunn_time_decision_screen=dunnTest(time ~ group, data = df_rt[df_rt$eventId==6,], method="bonferroni")

## last, make an annotated figure for this result:
H1.4_time_decision_screen_perGroup = ggplot(df_rt_summary[df_rt_summary$eventId==6,], aes(x=group, y=mean, fill=group)) + 
  geom_bar(stat="identity", color="black", 
           position=position_dodge()) +
  geom_errorbar(aes(ymin=mean-sem, ymax=mean+sem), width=.2,
                 position=position_dodge(.9))+
  labs(title="Mean time on decision screen per group",x="Group", y = "Mean time in s")+
  theme_bw(base_size = 10)+
  scale_y_continuous(expand = c(0,0),limits = c(0,14))+
  scale_fill_manual("Group", values=c(Ccol,Dcol,Ucol), labels = c("Control", "DiCE","UFCE"))+
  theme(plot.title = element_text(hjust = 0.5),legend.position = "bottom",legend.box="vertical")

# Add significance notation to plot:
H1.4_time_decision_screen_perGroup_anno = 
  H1.4_time_decision_screen_perGroup+
  theme(plot.title = element_text(hjust = 0.5),legend.position = "bottom",axis.ticks.x=element_blank(),axis.text.x=element_blank())+
  # first asterisk: C-U
  geom_segment(aes(x = 1, y = 7, xend = 1, yend = 13),colour = "black", size=0.2) +
  geom_segment(aes(x = 3, y = 12.5, xend = 3, yend =13),colour = "black", size=0.2) +
  geom_segment(aes(x = 1, y = 13, xend = 3, yend = 13),colour = "black", size=0.2) +
  geom_text(x = 2,  y = 13.5, label = "**", colour = "black")+
  # second asterisk: D-U
  geom_segment(aes(x = 2, y = 4.5, xend = 2, yend = 12.2),colour = "black", size=0.2) +
  geom_segment(aes(x = 3, y = 12, xend = 3, yend = 12.2),colour = "black", size=0.2) +
  geom_segment(aes(x = 2, y = 12.2, xend = 3, yend = 12.2),colour = "black", size=0.2) +
  geom_text(x = 2.5,  y = 12.5, label = "***", colour = "black")

# save
ggsave("Figures/H1.4_MeanTime_decision_screen_PerGroup_anno.pdf",width = 5, height = 3,)

# show
H1.4_time_decision_screen_perGroup_anno
### 

```

* Is there a significant difference in terms of average time spend on the config screen per group?

We performed a non-parametric Kruskal-Wallis test to investigate the main group effect, followed by Dunn's Test as posthoc evaluation, Bonferroni-corrected for multiple comparisons.

* This showed: chi-squared=`r Krusal_time_config_screen$statistic `, p=`r Krusal_time_config_screen$p.value `, df = `r Krusal_time_config_screen$parameter`, effect size eta-squared=`r Krusal_time_config_screen_effsize$effsize`.

Posthoc Dunn's Test revealed a significant difference for `r Krusal_time_config_screen$res$Comparison[1]` (Z=`r Krusal_time_config_screen$res$Z[1]`, adjusted p=`r Krusal_time_config_screen$res$P.adj[1]`),
for `r Krusal_time_config_screen$res$Comparison[2]` (Z=`r Krusal_time_config_screen$res$Z`,adjusted p=`r Krusal_time_config_screen$res$P.adj`),
but not between UFCE and DiCE (`r Krusal_time_config_screen$res$Comparison`,Z=`r Krusal_time_config_screen$res$Z`,adjusted p=`r Krusal_time_config_screen$res$P.adj`).

NEXT:  

* Is there a significant difference in terms of average time spend on the decision screen per group?

We performed a non-parametric Kruskal-Wallis test to investigate the main group effect, followed by Dunn's Test as posthoc evaluation, Bonferroni-corrected for multiple comparisons.

* This showed: chi-squared=`r Krusal_time_decision_screen$statistic `, p=`r Krusal_time_decision_screen$p.value `, df = `r Krusal_time_decision_screen$parameter`, effect size eta-squared=`r Krusal_time_decision_screen_effsize$effsize`.

Posthoc Dunn's Test revealed a significant difference for `r Krusal_time_decision_screen$res$Comparison[1]` (Z=`r Krusal_time_decision_screen$res$Z[1]`, adjusted p=`r Krusal_time_decision_screen$res$P.adj[1]`),
for `r Krusal_time_decision_screen$res$Comparison[2]` (Z=`r Krusal_time_decision_screen$res$Z[2]`,adjusted p=`r Krusal_time_decision_screen$res$P.adj[2]`),
but not between UFCE and DiCE (`r Krusal_time_decision_screen$res$Comparison[3]`,Z=`r Krusal_time_decision_screen$res$Z[3]`,adjusted p=`r Krusal_time_decision_screen$res$P.adj[3]`).

+ So YES! People in the DiCE group were overall a lot quicker. This could explain part of the observed performance differences in the groups.

##### H1.5 Analysis of user input for plant-2 and plant-4 (DiCE vs UFCE)
```{r echo=FALSE, warning=FALSE, eval = True}

# Filter records where newPred is 1 and group is 'D', 'U', or 'C'
df_D <- df_perf[df_perf$group == 'D' & df_perf$newPred == 1, ]
df_U <- df_perf[df_perf$group == 'U' & df_perf$newPred == 1, ]
df_C <- df_perf[df_perf$group == 'C' & df_perf$newPred == 1, ]


# Function to check if CFplant2 is different from plant2 and CFplant4 is different from plant4
check_CFplant_difference <- function(data) {
  sum(data$plant2 != data$CFplant2 & data$plant4 != data$CFplant4, na.rm = TRUE)
}

# Calculate the count of records where CFplant2 and CFplant4 are different from plant2 and plant4 for each group
count_D <- aggregate(cbind(CFplants_diff = plant2 != CFplant2 & plant4 != CFplant4) ~ userId, FUN = sum, data = df_D)
count_U <- aggregate(cbind(CFplants_diff = plant2 != CFplant2 & plant4 != CFplant4) ~ userId, FUN = sum, data = df_U)
count_C <- aggregate(cbind(CFplants_diff = plant2 != CFplant2 & plant4 != CFplant4) ~ userId, FUN = sum, data = df_C)

# Calculate the mean changes of CFplant2 and CFplant4 for each group
mean_changes_D <- mean(count_D$CFplants_diff)
mean_changes_U <- mean(count_U$CFplants_diff)
mean_changes_C <- mean(count_C$CFplants_diff)

# Plotting the mean changes for all three groups
barplot(c(mean_changes_D, mean_changes_U, mean_changes_C), names.arg = c('D', 'U', 'C'),
        xlab = 'Group', ylab = 'Mean Changes in CFplant2 and CFplant4',
        main = 'Mean Changes in CFplant2 and CFplant4 by Group (newPred = 1)')


##########

### considering all plants
df_D <- df_perf[df_perf$group == 'D' & df_perf$newPred == 1, ]
df_U <- df_perf[df_perf$group == 'U' & df_perf$newPred == 1, ]
df_C <- df_perf[df_perf$group == 'C' & df_perf$newPred == 1, ]

# Function to calculate the mean changes in each plant
calculate_mean_changes <- function(data) {
  sapply(1:5, function(i) mean(data[, paste0("plant", i)] != data[, paste0("CFplant", i)]))
}

# Calculate the mean changes for each plant across all groups
mean_changes_D <- calculate_mean_changes(df_D)
mean_changes_U <- calculate_mean_changes(df_U)
mean_changes_C <- calculate_mean_changes(df_C)

# Create a dataframe for easy plotting
df_mean_changes <- data.frame(Plant = paste0("Plant", 1:5),
                               D = mean_changes_D,
                               U = mean_changes_U
                              )

# Melt the dataframe for plotting
library(reshape2)
df_melted_mean <- melt(df_mean_changes, id.vars = "Plant")

# Plotting
library(ggplot2)
ggplot(df_melted_mean, aes(x = Plant, y = value, fill = variable)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(x = "Plant", y = "Mean Changes", fill = "Group") +
  geom_bar(stat="identity", color="black", 
           position=position_dodge()) +
  labs(title="Mean changes in plants per group",x="Group", y = "Mean changes")+
  theme_bw(base_size = 10)+
  scale_y_continuous(expand = c(0,0),limits = c(0,1))+
  scale_fill_manual("Group", values=c(Dcol,Ucol), labels = c("DiCE","UFCE"))+
  theme(plot.title = element_text(hjust = 0.5),legend.position = "bottom",legend.box="vertical")
# save
ggsave("Figures/H1.5_Mean_plantchanges_PerGroup.pdf",width = 5, height = 3,)

################

#reference_plants <- c(2, 1, 3, 1, 2)

# Function to calculate the mean changes for all users and all plants
#calculate_mean_changes <- function(data, reference_plants) {
#  plant_values <- data[, 6:10]  # Selecting plant values
#  mean(sapply(1:nrow(plant_values), function(i) sum(plant_values[i,] != reference_plants)))
#}

## Calculate the mean changes for all users and all plants for each group
#mean_changes_D <- calculate_mean_changes(df_D, reference_plants)
#mean_changes_U <- calculate_mean_changes(df_U, reference_plants)
#mean_changes_C <- calculate_mean_changes(df_C, reference_plants)

## Plotting
#barplot(c(mean_changes_D, mean_changes_U, mean_changes_C),
#        names.arg = c('D', 'U', 'C'),
#        xlab = 'Group', ylab = 'Mean Changes from Reference List',
#        main = 'Mean Changes from Reference List by Group')

```


#### Old Plots of Pilot-Study
```{r echo=FALSE, warning=FALSE, eval = FALSE}
### Old Plots of Pilot-Study

### Folllowing plots are not processed formally with new data

# from newly generated dataframe "df_perf_finAttempt", get information for plotting

# FIRST VERSION: ALL PARTICIPANTS (INDEPENDENT OF BEING SUCCESSFULL IN THAT ROUND OR NOT):

# Convert planetNo to a factor
df_perf_finAttempt = df_perf
df_perf_finAttempt=df_perf_finAttempt%>% group_by(userId,planetNo, group) %>% top_n(1, attemptNo)
df_perf_finAttempt$planetNo <- factor(df_perf_finAttempt$planetNo)
df_perf_finAttempt$group <- factor(df_perf_finAttempt$group)

df_perf_finAttempt

# function to compute mean, sd and sem
data_summary <- function(data, varname, groupnames){
  library(plyr)
  summary_func <- function(x, col){
    c(mean = mean(x[[col]], na.rm=TRUE),
      sd = sd(x[[col]], na.rm=TRUE),
      sem = sd(x[[col]], na.rm=TRUE)/sqrt(length(x[[col]])),
      N = length(x[[col]]))
  }
  data_sum<-ddply(data, groupnames, .fun=summary_func,
                  varname)
  return(data_sum)
}


df_perf_finAttempt_all_summaryAttempts=data_summary(df_perf_finAttempt, varname="attemptNo",groupnames=c("planetNo"))
df_perf_finAttempt_all_summaryFitness=data_summary(df_perf_finAttempt, varname="fitness_score",groupnames=c("planetNo"))

df_perf_finAttempt_all_summaryFitness


p_meanTrend_Attempts_all = ggplot(data=df_perf_finAttempt_all_summaryAttempts, aes(x=planetNo, y=mean)) + 
  geom_point(alpha = 0.5)+
  geom_line()+
  geom_ribbon(aes(ymin=mean-sd, ymax=mean+sd), linetype=2, alpha=0.1)+
  geom_hline(yintercept=3,linetype="dashed", color = "red")+
  labs(title="Mean number of attempts by planet number",x="Planet number", y = "Mean number of attempts")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Ccol,Dcol,Ucol), labels = c("Control", "DiCE", "UFCE"))+
  scale_y_continuous(limits = c(0, 3.3))
ggsave("./Figures/H1_meanTrend_Attempts_ALL_DATA.pdf",width = 5.5, height = 2.5, dpi = 600)
p_meanTrend_Attempts_all

# make figure: mean fitness score
p_meanTrend_Fitness_all = ggplot(data=df_perf_finAttempt_all_summaryFitness, aes(x=planetNo, y=mean)) + 
  geom_point(alpha = 0.5)+
  geom_line()+
  geom_ribbon(aes(ymin=mean-sd, ymax=mean+sd), linetype=2, alpha=0.1)+
  geom_hline(yintercept=15,linetype="dashed", color = "red")+
  labs(title="Mean fitness score by planet number",x="Planet number", y = "Mean fitness score")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Ccol,Dcol,Ucol), labels = c("Control", "DiCE", "UFCE"))+
  scale_y_continuous(limits = c(0, 16.5))
# ggsave("./Figures/H1_meanTrend_Fitness_ALL_DATA.pdf",width = 5.5, height = 2.5, dpi = 600)
p_meanTrend_Fitness_all

# make figure: participant attrition
p_meanTrend_participants_all = ggplot(data=df_perf_finAttempt_all_summaryFitness, aes(x=planetNo)) + 
  geom_bar(aes(y = N), stat="identity",position = position_dodge(preserve = "single"),fill = "skyblue")+
  geom_hline(yintercept=21,linetype="dashed", color = "red")+
  labs(title="Number of successful participants by planet number",x="Planet number", y = "Number of successful participants")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Ccol,Dcol,Ucol), labels = c("Control", "DiCE", "UFCE"))+
  scale_y_continuous(breaks=c(0,5,10,15,20),limits = c(0, 23))
# ggsave("./Figures/H1_meanTrend_Attempts_ALL_DATA.pdf",width = 5.5, height = 2.5, dpi = 600)
p_meanTrend_participants_all

# put all plots together
H1_performance_trends_allData <- ggarrange(p_meanTrend_Fitness_all+theme(plot.title = element_blank(),axis.title.x = element_blank()),p_meanTrend_Attempts_all+theme(plot.title = element_blank(), axis.title.x = element_blank()),p_meanTrend_participants_all+theme(plot.title = element_blank(),axis.title.x = element_blank()), labels = "AUTO", nrow = 1, ncol =3)

H1_performance_trends_allData= annotate_figure(
  H1_performance_trends_allData,
  bottom = "Planet number")

# save
# ggsave("./Figures/H1_performance_trends_allData_FINAL.pdf",width = 7, height = 3.5,)
H1_performance_trends_allData

# SECOND VERSION: ONLY PARTICIPANTS THAT SUCCEEDED TO INCREASE IN THAT ROUND ("WINNERS"):

# drop lines of participants not having "newPred == 1"
df_perf_finAttempt_winners=df_perf_finAttempt[!(df_perf_finAttempt$newPred==0),]

df_perf_finAttempt_winners_summaryAttempts=data_summary(df_perf_finAttempt_winners, varname="attemptNo",groupnames=c("planetNo"))
df_perf_finAttempt_winners_summaryFitness=data_summary(df_perf_finAttempt_winners, varname="fitness_score",groupnames=c("planetNo"))

# make figure: mean attempts
p_meanTrend_Attempts_winners = ggplot(data=df_perf_finAttempt_winners_summaryAttempts, aes(x=planetNo, y=mean)) + 
  geom_point(alpha = 0.5)+
  geom_line()+
  geom_ribbon(aes(ymin=mean-sd, ymax=mean+sd), linetype=2, alpha=0.1)+
  geom_hline(yintercept=3,linetype="dashed", color = "red")+
  labs(title="Mean number of attempts by planet number",x="Planet number", y = "Mean number of attempts")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Ccol,Dcol,Ucol), labels = c("Control", "DiCE", "UFCE"))+
  scale_y_continuous(limits = c(0, 3.42))
# ggsave("./Figures/H1_meanTrend_Attempts_WINNER_DATA.pdf",width = 5.5, height = 2.5, dpi = 600)

# make figure: mean fitness score
p_meanTrend_Fitness_winners = ggplot(data=df_perf_finAttempt_winners_summaryFitness, aes(x=planetNo, y=mean)) + 
  geom_point(alpha = 0.5)+
  geom_line()+
  geom_ribbon(aes(ymin=mean-sd, ymax=mean+sd), linetype=2, alpha=0.1)+
  geom_hline(yintercept=15,linetype="dashed", color = "red")+
  labs(title="Mean fitness score by planet number",x="Planet number", y = "Mean fitness score")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Ccol,Dcol,Ucol), labels = c("Control", "DiCE", "UFCE"))+
  scale_y_continuous(limits = c(0, 17.1))
# ggsave("./Figures/H1_meanTrend_Fitness_WINNER_DATA.pdf",width = 5.5, height = 2.5, dpi = 600)

# make figure: participant attrition
p_meanTrend_participants_winners = ggplot(data=df_perf_finAttempt_winners_summaryFitness, aes(x=planetNo)) + 
  geom_bar(aes(y = N), stat="identity",position = position_dodge(preserve = "single"),fill = "skyblue")+
  geom_hline(yintercept=21,linetype="dashed", color = "red")+
  labs(title="Number of successful participants by planet number",x="Planet number", y = "Number of successful participants")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Ccol,Dcol,Ucol), labels = c("Control", "DiCE", "UFCE"))+
  scale_y_continuous(breaks=c(0,5,10,15,20),limits = c(0, 23.9))
# ggsave("./Figures/H1_meanTrend_Fitness_WINNER_DATA.pdf",width = 5.5, height = 2.5, dpi = 600)

# put all plots together
H1_performance_trends_winnerData <- ggarrange(p_meanTrend_Fitness_winners+theme(plot.title = element_blank(),axis.title.x = element_blank()),p_meanTrend_Attempts_winners+theme(plot.title = element_blank(), axis.title.x = element_blank()),p_meanTrend_participants_winners+theme(plot.title = element_blank(),axis.title.x = element_blank()), labels = "AUTO", nrow = 1, ncol =3)

H1_performance_trends_winnerData= annotate_figure(
  H1_performance_trends_winnerData,
  bottom = "Planet number")

H1_performance_trends_winnerData
# save
# ggsave("./Figures/H1_performance_trends_winnerData_FINAL.pdf",width = 7, height = 3.5,)

```



```{r echo=FALSE, eval=FALSE}

# # Calculate the mean attempts for all users
# mean_attempts_all_users <- mean(avg_attempts_df$avgAttempts)
# 
# # Plot all users' attempts around the mean attempts
# ggplot(avg_attempts_df, aes(x = avgAttempts, y = 1)) +
#   geom_point(aes(color = userId), alpha = 0.5) +
#   geom_vline(xintercept = mean_attempts_all_users, linetype = "dashed", color = "red") +
#   labs(x = "Average Attempts", y = "", title = "Users' Attempts Distribution") +
#   scale_color_manual(values = rep("blue", length(common_userId))) +
#   theme_minimal() +
#   theme(axis.text.y = element_blank(),
#         axis.title.y = element_blank(),
#         legend.position = "none",
#         axis.text.x = element_text(size=10),
#         axis.title.x = element_text(size=12))
#print(avg_attempts_df)
```

```{r echo=FALSE, warning=FALSE, eval=FALSE}


## Convert relevant columns to numeric
#df_perf$attemptNo <- as.numeric(df_perf$attemptNo)
#df_perf$fitness_score <- as.numeric(df_perf$fitness_score)

## Filter users who always increased fitness_score on 1st, 2nd, and 3rd attempt
#filtered_data <- df_perf %>%
#  group_by(userId) %>%
#  filter(all(diff(fitness_score) > 0)) %>%
#  ungroup()

## Convert planetNo to a factor
#filtered_data$planetNo <- factor(filtered_data$planetNo)

## Calculate the mean fitness_score for each planet
#mean_data <- filtered_data %>%
#  group_by(attemptNo, planetNo) %>%
#  summarise(mean_fitness_score = mean(fitness_score, na.rm = TRUE)) %>%
#  ungroup()

# Create a line plot for mean trend
#ggplot(mean_data, aes(x = planetNo, y = mean_fitness_score, group = factor(attemptNo), color = factor(attemptNo))) +
#  geom_line() +
#  labs(title = "Mean Trend of Fitness Score for Users with Increasing Score by Attempt Number",
#       x = "Planet Number",
#       y = "Mean Fitness Score",
#       color = "Attempt Number") +
#  theme_minimal()


```

```{r echo=FALSE, warning=FALSE, eval=FALSE}


# # Convert relevant columns to numeric
# df_perf$attemptNo <- as.numeric(df_perf$attemptNo)
# df_perf$fitness_score <- as.numeric(df_perf$fitness_score)
# 
# # Identify users who improved fitness_score from one planet to another
# improved_users <- df_perf %>%
#   group_by(userId) %>%
#   filter(
#     (sum(diff(fitness_score) > 0 & planetNo == 1 & lead(planetNo) == 1)) > 0 |
#     (sum(diff(fitness_score) > 0 & planetNo == 2 & lead(planetNo) == 2)) > 0 |
#     (sum(diff(fitness_score) > 0 & planetNo == 3 & lead(planetNo) == 3)) > 0
#   ) %>%
#   ungroup()
# 
# # Calculate the percentage of users who improved fitness_score
# total_users <- n_distinct(df_perf$userId)
# improved_users_count <- n_distinct(improved_users$userId)
# 
# # Calculate the percentage for each improvement
# percentage_improved_1_to_2 <- sum(improved_users$planetNo == 2 & lag(improved_users$planetNo) == 2) / total_users * 100
# percentage_improved_2_to_3 <- sum(improved_users$planetNo == 2 & lag(improved_users$planetNo) == 2) / total_users * 100
# percentage_improved_3_to_3 <- sum(improved_users$planetNo == 2 & lag(improved_users$planetNo) == 3) / total_users * 100
# 
# # Create a bar plot for the percentage of users who improved fitness_score
# ggplot() +
#   geom_bar(aes(x = c("planet-1 to planet-2", "planet-2 to planet-3", "planet-2 to planet-3"), 
#                y = c(percentage_improved_1_to_2, percentage_improved_2_to_3, percentage_improved_3_to_3)),
#            stat = "identity", fill = "skyblue", width = 0.5) +
#   labs(title = "",
#        x = "",
#        y = "Percentage of Users") +
#   theme_bw(base_size = 10)+
#   scale_y_continuous(labels = scales::percent_format(scale = 1)) +
#   theme_minimal()
#   theme(plot.title = element_text(hjust = 0.5))
#   
#ggsave("Figures/new/H1.2_task_perf_improvement.pdf",width = 5, height = 2.5, dpi = 500,)

```

```{r echo=FALSE, eval=FALSE}


# # Create a label for each userId
# avg_attempts_df$userId_label <- paste0("u-", as.integer(as.factor(avg_attempts_df$userId)))
# 
# # Plot planetNo and avgAttempts with userId as labels on x-axis
# ggplot(avg_attempts_df, aes(x = userId_label, y = avgAttempts)) +
#   geom_point(aes(color = factor(planetNo)), size = 3) +
#   labs(x = "User ID", y = "Average Attempts", title = "Average Attempts by User and Planet") +
#   theme_minimal() +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels for better readability

```

## Subjective Understanding/Learning (Survey items responses)


### survey item 3 and 4 
* Item 3. [Explanation group:] I often used the Help button to get suggestions on what choice would have led to a better result. [EXPLANATION REQUEST BEHAVIOUR; source: IAZ]

* Item 3. [Control group:] I would have liked to have a Help button to get suggestions on what choice would have led to a better result. [EXPLANATION DESIRE; source: specific to this study]



* Item 4. [Explanation group:] I did not understand the suggestions on what choice would have led to a better result provided by the Help button. [UNDERSTANDING OF EXPLANATIONS; specific to this study]

* Item 4. [Control group:] I needed no support to understand which selection choices would have led to a better result.[NEED FOR SUPPORT IN CONTROL CASE; specific to this study]

#### Explanation groups

```{r echo=FALSE, warning=FALSE, fig.height = 5.5, fig.width = 4.5}

# Descriptive stats
# subset to get only relevant data
df_survey_item3_item4=df_survey[(df_survey$itemNo==3 | df_survey$itemNo==4) & (!df_survey$group=='C'),]

# set itemNo and responseNo to factors, too
df_survey_item3_item4$itemNo=as.factor(df_survey_item3_item4$itemNo)
df_survey_item3_item4$responseNo=as.factor(df_survey_item3_item4$responseNo)

# summary(df_survey_item3_item4)

# summarize to get overview values of frequencies and percentages
df_survey_item3_item4_summary=dplyr::summarise(group_by(df_survey_item3_item4, group, itemNo, responseNo),
          SumChecks=sum(checked),
          PercUsersChecked=100*(sum(checked)/length(unique(userId))))

# display frequency as raw counts
item3_item4_p_FreqUserResponses = ggplot(data=df_survey_item3_item4_summary, aes(x=responseNo,fill = group)) + 
  geom_bar(aes(y = SumChecks),stat="identity",position = position_dodge(preserve = "single"))+
  facet_wrap(vars(itemNo),nrow = 2, ncol = 1,labeller=as_labeller(c(`3`="\"I often used the Help button to get suggestions.\"",`4`="\"I did not understand the suggestions on what choice would have led to a better.\"")))+
  labs(title="Item 3 and 4 Experimental",x="", y = "Frequency of answer")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Dcol,Ucol), labels = c("DiCE","UFCE"))+
  scale_x_discrete(breaks=1:6, labels=c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree","Prefer not\nto answer"))+
  theme(plot.title = element_text(hjust = 0.5),axis.text.x = element_text(angle = 60,hjust = 0.95))

# display frequency as percentage of all per group users (how many % of explanation users picked plant 1?)
item3_item4_p_PercUserResponses = ggplot(data=df_survey_item3_item4_summary, aes(x=responseNo,fill = group)) + 
  geom_bar(aes(y = PercUsersChecked),stat="identity",position = position_dodge(preserve = "single"))+
  facet_wrap(vars(itemNo),nrow = 2, ncol = 1,labeller=as_labeller(c(`3`="\"I often used the Help button to get suggestions\"",`4`="\"I did not understand the suggestions on what choice would have led to a better.\"")))+
  labs(title="Item 3 and 4 Experimental",x="", y = "% of users per group")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Dcol,Ucol), labels = c("DiCE","UFCE"))+
  scale_x_discrete(breaks=1:6, labels=c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree","Prefer not\nto answer"))+
  theme(plot.title = element_text(hjust = 0.5),axis.text.x = element_text(angle = 60,hjust = 0.95))

# safe summary to generate likert plots:
likert_item3_item4=df_survey_item3_item4_summary

# put all plots together
item3_item4_figure1_UserResponses <- ggarrange(item3_item4_p_FreqUserResponses,item3_item4_p_PercUserResponses,
                    ncol = 1, nrow = 2, heights=c(4,4), common.legend = TRUE)

# save
# ggsave("Figures/item_3_and_4_UserResponses_EXP.pdf",width = 5, height = 6,)

# show
# print("Display figures showing user responses in relevant survey items:")
item3_item4_figure1_UserResponses

```
On to the statistical comparison: for Likert-scale, we want a non-parametric statistical test for ordinal data, that's the WilcoxonMannWhitney U test.

```{r echo=FALSE, fig.height = 3, fig.width = 5, fig.align = "center"}

# extract response numbers per participant
df_survey_subjHelpfulness_responses = df_survey_item3_item4[df_survey_item3_item4$itemNo==3,]
df_survey_subjHelpfulness_responses = df_survey_subjHelpfulness_responses[!df_survey_subjHelpfulness_responses$checked==0,]
# take out "prefer not to answer" replies
df_survey_subjHelpfulness_responses = df_survey_subjHelpfulness_responses[!df_survey_subjHelpfulness_responses$responseNo==6,]

df_survey_subjUsability_responses = df_survey_item3_item4[df_survey_item3_item4$itemNo==4,]
df_survey_subjUsability_responses = df_survey_subjUsability_responses[!df_survey_subjUsability_responses$checked==0,]
# take out "prefer not to answer" replies
df_survey_subjUsability_responses = df_survey_subjUsability_responses[!df_survey_subjUsability_responses$responseNo==6,]

# treat as numeric to compute stats
df_survey_subjHelpfulness_responses$responseNo=as.numeric(df_survey_subjHelpfulness_responses$responseNo)
df_survey_subjUsability_responses$responseNo=as.numeric(df_survey_subjUsability_responses$responseNo)

# compute summary stats (mean, sd, sem)
df_survey_subjHelpfulness_summary=data_summary(df_survey_subjHelpfulness_responses, varname="responseNo", 
                    groupnames=c("group"))

df_survey_subjUsability_summary=data_summary(df_survey_subjUsability_responses, varname="responseNo", 
                    groupnames=c("group"))

# for plotting:
df_survey_subjHelpUsability_responses = df_survey_item3_item4[!df_survey_item3_item4$checked==0,]
df_survey_subjHelpUsability_responses = df_survey_subjHelpUsability_responses[!df_survey_subjHelpUsability_responses$responseNo==6,]
df_survey_subjHelpUsability_responses$responseNo=as.numeric(df_survey_subjHelpUsability_responses$responseNo)

# plot distribution
H2.1_figure2_UserResponses_violin = ggplot(df_survey_subjHelpUsability_responses, aes(x=group, y=responseNo, color=group, fill=group)) + 
  geom_violin(scale = "count")+
  geom_boxplot(width=0.1)+
  # geom_jitter(height = 0, width = 0.1)+ # ADD THIS TO DISPLAY INDIVIDUAL DATA POINTS!
  facet_wrap(vars(itemNo),nrow = 2, ncol = 1,labeller=as_labeller(c(`3`="\"I often used the Help button to get suggestions.\"",`4`="\"I did not understand the suggestions.\""))) +
  stat_summary(fun=mean, geom="point", shape=23, size=2, color="red")  +
  labs(title="Mean response for subjective helpfulness / usability",x="Group", y = "Response")+
  scale_y_continuous(limits = c(1, 5),breaks=1:5, labels=c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree"))+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=alpha(c(Dcol,Ucol),0.2), labels = c("DiCE","UFCE"))+
  scale_color_manual("Group", values=c(Dcol,Ucol), labels = c("DiCE","UFCE"))+
  theme(plot.title = element_text(hjust = 0.5))

# save
# ggsave("Figures/H2.1_item_3_and_4_UserResponses_violin.pdf",width = 6, height = 4,)
H2.1_figure2_UserResponses_violin

# Stacked bar plot, the more appropriate visualization for likert data:
# separate "high" and "low" values
lows=likert_item3_item4[as.numeric(likert_item3_item4$responseNo)<4,]
highs=likert_item3_item4[as.numeric(likert_item3_item4$responseNo)>2,]
# NOTE: we take response no 6 out here, after percentages were computed
# THUS, THE RESPONSES WILL NOT SUM UP TO 100% ID PEOPLE CHOSE NOT TO ANSWER!
highs=highs[!highs$responseNo==6,]
  
# divide neutral category by 2 for plotting:
lows$PercUsersChecked[lows$responseNo==3]=lows$PercUsersChecked[lows$responseNo==3]/2
highs$PercUsersChecked[highs$responseNo==3]=highs$PercUsersChecked[highs$responseNo==3]/2

H2.1_figure2_UserResponses_stackedBar = ggplot() + scale_x_discrete(labels=c("U"="UFCE", "D"="DiCE")) +
  # annotation:
  annotate("rect", xmin = 1.6, xmax = 2.4, ymin = -100, ymax = 100, alpha=0.2, fill = Ucol)+
  # annotate("rect", xmin = 0.6, xmax = 1.4, ymin = -100, ymax = 100, alpha=0.2, fill = Ccol)+
  annotate("rect", xmin = 0.6, xmax = 1.4, ymin = -100, ymax = 100, alpha=0.2, fill = Dcol)+
  # geom_bar, add data high:
  geom_bar(data=highs[order(highs$responseNo, decreasing = F),], aes(x = group, y=PercUsersChecked, fill=responseNo, group=group), position="stack", stat="identity",width = 0.5) +
  # add border for high values:
  stat_summary(data=highs[order(highs$responseNo, decreasing = F),], aes(x = group, y = PercUsersChecked),
               fun = sum,geom = "col",colour = "black",fill=NA,width = 0.5,size=0.1)+
  # geom_bar, add data low:
  geom_bar(data=lows[order(lows$responseNo, decreasing = T),], aes(x = group, y=-PercUsersChecked, fill=responseNo, group=group), position="stack", stat="identity",width = 0.5) +
  # add border for high values:
  stat_summary(data=lows[order(lows$responseNo, decreasing = T),], aes(x = group, y=-PercUsersChecked),
               fun = sum,geom = "col",colour = "black",fill=NA,width = 0.5,size=0.1)+
  # flip coordinates:
  coord_flip(xlim=c(0.99,2.3)) +
  # more aesthetics:
  geom_hline(yintercept = 0, color =c("black"),size=0.1) +
  facet_wrap(vars(itemNo),nrow = 3, ncol = 1,labeller=as_labeller(c(`3`="\"I often used the Help button to get suggestions.\"",`4`="\"I did not understand the suggestions on what choice would have led to a better result.\"")))+
  theme_bw(base_size = 10)+
theme(legend.position = "bottom",legend.title=element_blank(),legend.background = element_rect(fill="gray90", size=.5, linetype="dotted"),plot.title = element_text(hjust = 0.5))+
  labs(x="Group", y ="% of users")+
  scale_fill_manual("User response", values = likert_Okabe_Ito_palette,labels = c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree"))+
  scale_color_manual("Group", values=c(Dcol,Ucol), labels = c("DiCE","UFCE"))+
  scale_y_continuous(labels=c(100,50,0,50,100))

# save
# ggsave("Figures/H2.1_item3_and_4_UserResponses_stackedBar_EXP.pdf",width = 5, height = 3,)
H2.1_figure2_UserResponses_stackedBar
# show plots
# print("Mean user response for subjective helpfulness / usability:")
# H2.1_figure2_UserResponses_violin
# H2.1_figure2_UserResponses_stackedBar

# # run stats, helpfulness judgements:
item3t="Wilcox"
item3test=uk_wilcox.test(df_survey_subjHelpfulness_responses$responseNo[df_survey_subjHelpfulness_responses$group=="U"],df_survey_subjHelpfulness_responses$responseNo[df_survey_subjHelpfulness_responses$group=="D"],paired=FALSE,exact=FALSE)
item3effsize=item3test$z_val/(sqrt(nrow(df_survey_subjHelpfulness_responses)))
#
matchingRes=paste(matchingRes,paste("\n","H2.1_item_3_4_Userresponses",sep=""),"NA",item3t,item3test$p.value,item3effsize,sep = ",")
#
# run stats, usability judgements:
item4t="Wilcox"
item4test=uk_wilcox.test(df_survey_subjUsability_responses$responseNo[df_survey_subjUsability_responses$group=="U"],df_survey_subjUsability_responses$responseNo[df_survey_subjUsability_responses$group=="D"],paired=FALSE,exact=FALSE)
item4effsize=item4test$z_val/(sqrt(nrow(df_survey_subjUsability_responses)))
#
matchingRes=paste(matchingRes,paste("\n","H2.1_item_3_4_UserResponses",sep=""),"NA",item4t,item4test$p.value,item4effsize,sep = ",")

item4test$p.value
# item4test$statistic
# item4effsize
item3test$p.value
```
The analysis revealed:

* Is there a significant difference in terms of using the help button between the explanation groups? 

We compared responses users in UFCE (M = `r df_survey_subjHelpfulness_summary$mean[df_survey_subjHelpfulness_summary$group=="U"]`, SEM = `r df_survey_subjHelpfulness_summary$sem[df_survey_subjHelpfulness_summary$group=="U"]`) and users in the DiCE (M = `r df_survey_subjHelpfulness_summary$mean[df_survey_subjHelpfulness_summary$group=="D"]`, SEM = `r df_survey_subjHelpfulness_summary$sem[df_survey_subjHelpfulness_summary$group=="D"]`) using a WilcoxonMannWhitney U test. This showed: U=`r item3test$statistic `, p=`r item3test$p.value `, r = `r item3effsize `

* Is there a significant difference in terms of understanding the suggestions?: 
We compared responses for subjective usability for users in explanation condition (M = `r df_survey_subjUsability_summary$mean[df_survey_subjUsability_summary$group=="U"]`, SEM = `r df_survey_subjUsability_summary$sem[df_survey_subjUsability_summary$group=="U"]`) and users in the control condition (M = `r df_survey_subjUsability_summary$mean[df_survey_subjUsability_summary$group=="D"]`, SEM = `r df_survey_subjUsability_summary$sem[df_survey_subjUsability_summary$group=="D"]`) using a WilcoxonMannWhitney U test. This showed: U=`r item4test$statistic `, p=`r item4test$p.value `, r = `r item4effsize `



```{r echo=FALSE, fig.height = 3, fig.width = 5, fig.align = "center"}
# add significance annotation to likert plots:

anno_df <- data.frame(label = c("n.s.(p=0.637)", "n.s.(p=0.167)"),itemNo   = c(3, 4))
H2.1_figure2_UserResponses_stackedBar_anno = H2.1_figure2_UserResponses_stackedBar + geom_text(
  data = anno_df, mapping = aes(x = Inf, y = -Inf, label = label), hjust = -0.1, vjust = 1.5, size=2, fontface = "italic")

# save
ggsave("Figures/final/item_3_4_UserResponses_stackedBar_anno_EXP.pdf",width = 6, height = 5,)

# show plots
# print("Mean user response for help button and understanding of suggestions:")
#H2.1_figure2_UserResponses_stackedBar_anno

```



#### Control group (item 3 and 4)

```{r echo=FALSE, warning=FALSE, fig.height = 5.5, fig.width = 4.5}

# Descriptive stats
# subset to get only relevant data
df_survey_item3_item4=df_survey[(df_survey$itemNo==3 | df_survey$itemNo==4) & (df_survey$group=='C'),]

# set itemNo and responseNo to factors, too
df_survey_item3_item4$itemNo=as.factor(df_survey_item3_item4$itemNo)
df_survey_item3_item4$responseNo=as.factor(df_survey_item3_item4$responseNo)

# summary(df_survey_item3_item4)

# summarize to get overview values of frequencies and percentages
df_survey_item3_item4_summary=dplyr::summarise(group_by(df_survey_item3_item4, group, itemNo, responseNo),
          SumChecks=sum(checked),
          PercUsersChecked=100*(sum(checked)/length(unique(userId))))

# display frequency as raw counts
item3_item4_p_FreqUserResponses = ggplot(data=df_survey_item3_item4_summary, aes(x=responseNo,fill = group)) + 
  geom_bar(aes(y = SumChecks),stat="identity",position = position_dodge(preserve = "single"))+
  facet_wrap(vars(itemNo),nrow = 2, ncol = 1,labeller=as_labeller(c(`3`="\"I would have liked to have a Help button to get suggestions.\"",`4`="\"I needed no support to understand selection choices.\"")))+
  labs(title="Item 3 and 4 Control group",x="", y = "Frequency of answer")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Ccol), labels = c("Control"))+
  scale_x_discrete(breaks=1:6, labels=c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree","Prefer not\nto answer"))+
  theme(plot.title = element_text(hjust = 0.5),axis.text.x = element_text(angle = 60,hjust = 0.95))

# display frequency as percentage of all per group users (how many % of explanation users picked plant 1?)
item3_item4_p_PercUserResponses = ggplot(data=df_survey_item3_item4_summary, aes(x=responseNo,fill = group)) + 
  geom_bar(aes(y = PercUsersChecked),stat="identity",position = position_dodge(preserve = "single"))+
  facet_wrap(vars(itemNo),nrow = 2, ncol = 1,labeller=as_labeller(c(`3`="\"I would have liked to have a Help button to get suggestions.\"",`4`="\"I needed no support to understand selection choices.\"")))+
  labs(title="Item 3 and 4 Control",x="", y = "% of users per group")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Ccol), labels = c("Control"))+
  scale_x_discrete(breaks=1:6, labels=c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree","Prefer not\nto answer"))+
  theme(plot.title = element_text(hjust = 0.5),axis.text.x = element_text(angle = 60,hjust = 0.95))

# safe summary to generate likert plots:
likert_item3_item4=df_survey_item3_item4_summary

# put all plots together
item3_item4_figure1_UserResponses <- ggarrange(item3_item4_p_FreqUserResponses,item3_item4_p_PercUserResponses,
                    ncol = 1, nrow = 2, heights=c(4,4), common.legend = TRUE)

# save
# ggsave("Figures/item_3_and_4_UserResponses_control.pdf",width = 5, height = 6,)

# show
# print("Display figures showing user responses in relevant survey items:")
item3_item4_figure1_UserResponses

```
On to the statistical comparison: for Likert-scale, we want a non-parametric statistical test for ordinal data, that's the WilcoxonMannWhitney U test.

```{r echo=FALSE, fig.height = 3, fig.width = 5, fig.align = "center"}

# extract response numbers per participant
df_survey_subjHelpfulness_responses = df_survey_item3_item4[df_survey_item3_item4$itemNo==3,]
df_survey_subjHelpfulness_responses = df_survey_subjHelpfulness_responses[!df_survey_subjHelpfulness_responses$checked==0,]
# take out "prefer not to answer" replies
df_survey_subjHelpfulness_responses = df_survey_subjHelpfulness_responses[!df_survey_subjHelpfulness_responses$responseNo==6,]

df_survey_subjUsability_responses = df_survey_item3_item4[df_survey_item3_item4$itemNo==4,]
df_survey_subjUsability_responses = df_survey_subjUsability_responses[!df_survey_subjUsability_responses$checked==0,]
# take out "prefer not to answer" replies
df_survey_subjUsability_responses = df_survey_subjUsability_responses[!df_survey_subjUsability_responses$responseNo==6,]

# treat as numeric to compute stats
df_survey_subjHelpfulness_responses$responseNo=as.numeric(df_survey_subjHelpfulness_responses$responseNo)
df_survey_subjUsability_responses$responseNo=as.numeric(df_survey_subjUsability_responses$responseNo)

# compute summary stats (mean, sd, sem)
df_survey_subjHelpfulness_summary=data_summary(df_survey_subjHelpfulness_responses, varname="responseNo", 
                    groupnames=c("group"))

df_survey_subjUsability_summary=data_summary(df_survey_subjUsability_responses, varname="responseNo", 
                    groupnames=c("group"))

# for plotting:
df_survey_subjHelpUsability_responses = df_survey_item3_item4[!df_survey_item3_item4$checked==0,]
df_survey_subjHelpUsability_responses = df_survey_subjHelpUsability_responses[!df_survey_subjHelpUsability_responses$responseNo==6,]
df_survey_subjHelpUsability_responses$responseNo=as.numeric(df_survey_subjHelpUsability_responses$responseNo)

# plot distribution
H2.1_figure2_UserResponses_violin = ggplot(df_survey_subjHelpUsability_responses, aes(x=group, y=responseNo, color=group, fill=group)) + 
  geom_violin(scale = "count")+
  geom_boxplot(width=0.1)+
  # geom_jitter(height = 0, width = 0.1)+ # ADD THIS TO DISPLAY INDIVIDUAL DATA POINTS!
  facet_wrap(vars(itemNo),nrow = 2, ncol = 1,labeller=as_labeller(c(`3`="\"I would have liked to have a Help button.\"",`4`="\"I needed no support to understand selection choices.\""))) +
  stat_summary(fun=mean, geom="point", shape=23, size=2, color="red")  +
  labs(title="Mean response for Need for Support",x="Group", y = "Response")+
  scale_y_continuous(limits = c(1, 5),breaks=1:5, labels=c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree"))+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=alpha(c(Ccol),0.2), labels = c("Control"))+
  scale_color_manual("Group", values=c(Dcol,Ucol), labels = c("Control"))+
  theme(plot.title = element_text(hjust = 0.5))

# save
#ggsave("Figures/H2.1_item_3_and_4_UserResponses_violin_control.pdf",width = 6, height = 4,)
#H2.1_figure2_UserResponses_violin

# Stacked bar plot, the more appropriate visualization for likert data:
# separate "high" and "low" values
lows=likert_item3_item4[as.numeric(likert_item3_item4$responseNo)<4,]
highs=likert_item3_item4[as.numeric(likert_item3_item4$responseNo)>2,]
# NOTE: we take response no 6 out here, after percentages were computed
# THUS, THE RESPONSES WILL NOT SUM UP TO 100% ID PEOPLE CHOSE NOT TO ANSWER!
highs=highs[!highs$responseNo==6,]
  
# divide neutral category by 2 for plotting:
lows$PercUsersChecked[lows$responseNo==3]=lows$PercUsersChecked[lows$responseNo==3]/2
highs$PercUsersChecked[highs$responseNo==3]=highs$PercUsersChecked[highs$responseNo==3]/2

H2.1_figure2_UserResponses_stackedBar = ggplot() + scale_x_discrete(labels=c("C"="Control")) +
  # annotation:
  # annotate("rect", xmin = 1.6, xmax = 2.4, ymin = -100, ymax = 100, alpha=0.2, fill = Ucol)+
  annotate("rect", xmin = 0.6, xmax = 1.4, ymin = -100, ymax = 100, alpha=0.2, fill = Ccol)+
  # annotate("rect", xmin = 0.6, xmax = 1.4, ymin = -100, ymax = 100, alpha=0.2, fill = Dcol)+
  # geom_bar, add data high:
  geom_bar(data=highs[order(highs$responseNo, decreasing = F),], aes(x = group, y=PercUsersChecked, fill=responseNo, group=group), position="stack", stat="identity",width = 0.5) +
  # add border for high values:
  stat_summary(data=highs[order(highs$responseNo, decreasing = F),], aes(x = group, y = PercUsersChecked),
               fun = sum,geom = "col",colour = "black",fill=NA,width = 0.5,size=0.1)+
  # geom_bar, add data low:
  geom_bar(data=lows[order(lows$responseNo, decreasing = T),], aes(x = group, y=-PercUsersChecked, fill=responseNo, group=group), position="stack", stat="identity",width = 0.5) +
  # add border for high values:
  stat_summary(data=lows[order(lows$responseNo, decreasing = T),], aes(x = group, y=-PercUsersChecked),
               fun = sum,geom = "col",colour = "black",fill=NA,width = 0.5,size=0.1)+
  # flip coordinates:
  coord_flip(xlim=c(0.99,2.3)) +
  # more aesthetics:
  geom_hline(yintercept = 0, color =c("black"),size=0.1) +
  facet_wrap(vars(itemNo),nrow = 3, ncol = 1,labeller=as_labeller(c(`3`="\"I would have liked to have a Help button.\"",`4`="\"I needed no support to understand selection choices.\"")))+
  theme_bw(base_size = 10)+
theme(legend.position = "bottom",legend.title=element_blank(),legend.background = element_rect(fill="gray90", size=.5, linetype="dotted"),plot.title = element_text(hjust = 0.5))+
  labs(x="Group", y ="% of users")+
  scale_fill_manual("User response", values = likert_Okabe_Ito_palette,labels = c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree"))+
  scale_color_manual("Group", values=c(Ccol), labels = c("Control"))+
  scale_y_continuous(labels=c(100,50,0,50,100))

# save
ggsave("Figures/final/item3_4_UserResponses_stackedBar_control.pdf",width = 5, height = 3,)
H2.1_figure2_UserResponses_stackedBar
# show plots
# print("Mean user response for subjective helpfulness / usability:")
# H2.1_figure2_UserResponses_violin
# H2.1_figure2_UserResponses_stackedBar

# # run stats, helpfulness judgements:
# item3t="Wilcox"
# item3test=uk_wilcox.test(df_survey_subjHelpfulness_responses$responseNo[df_survey_subjHelpfulness_responses$group=="U"],df_survey_subjHelpfulness_responses$responseNo[df_survey_subjHelpfulness_responses$group=="D"],paired=FALSE,exact=FALSE)
# item3effsize=item3test$z_val/(sqrt(nrow(df_survey_subjHelpfulness_responses)))
# 
# matchingRes=paste(matchingRes,paste("\n","H2.1_item_3_4_Userresponses",sep=""),"NA",item3t,item3test$p.value,item3effsize,sep = ",")
# 
# # run stats, usability judgements:
# item4t="Wilcox"
# item4test=uk_wilcox.test(df_survey_subjUsability_responses$responseNo[df_survey_subjUsability_responses$group=="U"],df_survey_subjUsability_responses$responseNo[df_survey_subjUsability_responses$group=="D"],paired=FALSE,exact=FALSE)
# item4effsize=item4test$z_val/(sqrt(nrow(df_survey_subjUsability_responses)))
# 
# matchingRes=paste(matchingRes,paste("\n","H2.1_item_3_4_UserResponses",sep=""),"NA",item4t,item4test$p.value,item4effsize,sep = ",")
# 
# print(item5test$p.value)

```



```{r echo=FALSE, fig.height = 3, fig.width = 5, fig.align = "center", eval=FALSE}
# # add significance annotation to likert plots:
# 
# anno_df <- data.frame(label = c("*** (p<.001)", "*** (p<.001)"),itemNo   = c(3, 4))
# H2.1_figure2_UserResponses_stackedBar_anno = H2.1_figure2_UserResponses_stackedBar + geom_text(
#   data = anno_df, mapping = aes(x = Inf, y = -Inf, label = label), hjust = -0.1, vjust = 1.5, size=2, fontface = "italic")
# 
# # save
# ggsave("Figures/H2.1_figure2_UserResponses_stackedBar_anno.pdf",width = 6, height = 5,)
# 
# # show plots
# print("Mean user response for subjective helpfulness / usability:")
# H2.1_figure2_UserResponses_stackedBar_anno

```

### survey item 5 Actionability (Exp)

Item 5. I have learned from the suggestions on what choice would have led to a better result provided by the Help button how to select a good diet to increase the fitness of the Shub.  [ACTIONABILITY OF EXPLANATIONS, source: Vilone/Hoffman revised] 


```{r echo=FALSE, warning=FALSE, fig.height = 5.5, fig.width = 4.5}

# Descriptive stats
# subset to get only relevant data
df_survey_item5=df_survey[(df_survey$itemNo==5) & (!df_survey$group=='C'),]

# set itemNo and responseNo to factors, too
df_survey_item5$itemNo=as.factor(df_survey_item5$itemNo)
df_survey_item5$responseNo=as.factor(df_survey_item5$responseNo)

# summary(df_survey_item5)

# summarize to get overview values of frequencies and percentages
df_survey_item5_summary=dplyr::summarise(group_by(df_survey_item5, group, itemNo, responseNo),
          SumChecks=sum(checked),
          PercUsersChecked=100*(sum(checked)/length(unique(userId))))

# display frequency as raw counts
item5_p_FreqUserResponses = ggplot(data=df_survey_item5_summary, aes(x=responseNo,fill = group)) + 
  geom_bar(aes(y = SumChecks),stat="identity",position = position_dodge(preserve = "single"))+
  facet_wrap(vars(itemNo),nrow = 1, ncol = 1,labeller=as_labeller(c(`5`="\"Actionability.\"")))+
  labs(title="Item 5 actionability",x="", y = "Frequency of answer")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Dcol,Ucol), labels = c("DiCE","UFCE"))+
  scale_x_discrete(breaks=1:6, labels=c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree","Prefer not\nto answer"))+
  theme(plot.title = element_text(hjust = 0.5),axis.text.x = element_text(angle = 60,hjust = 0.95))

# display frequency as percentage of all per group users (how many % of explanation users picked plant 1?)
item5_p_PercUserResponses = ggplot(data=df_survey_item5_summary, aes(x=responseNo,fill = group)) + 
  geom_bar(aes(y = PercUsersChecked),stat="identity",position = position_dodge(preserve = "single"))+
  facet_wrap(vars(itemNo),nrow = 1, ncol = 1,labeller=as_labeller(c(`5`="\"Actionability.\"")))+
  labs(title="Item 5 actionability",x="", y = "% of users per group")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Dcol,Ucol), labels = c("DiCE","UFCE"))+
  scale_x_discrete(breaks=1:6, labels=c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree","Prefer not\nto answer"))+
  theme(plot.title = element_text(hjust = 0.5),axis.text.x = element_text(angle = 60,hjust = 0.95))

# safe summary to generate likert plots:
likert_item5=df_survey_item5_summary

# put all plots together
item5_figure1_UserResponses <- ggarrange(item5_p_FreqUserResponses,item5_p_PercUserResponses,
                    ncol = 1, nrow = 1, heights=c(4,4), common.legend = TRUE)

# save
# ggsave("Figures/item_5_actionability_UserResponses.pdf",width = 5, height = 6,)

# show
# print("Display figures showing user responses in relevant survey items:")
item5_figure1_UserResponses

```
On to the statistical comparison: for Likert-scale, we want a non-parametric statistical test for ordinal data, that's the WilcoxonMannWhitney U test.

```{r echo=FALSE, fig.height = 3, fig.width = 5, fig.align = "center"}

# extract response numbers per participant
df_survey_subjHelpfulness_responses = df_survey_item5[df_survey_item5$itemNo==5,]
df_survey_subjHelpfulness_responses = df_survey_subjHelpfulness_responses[!df_survey_subjHelpfulness_responses$checked==0,]
# take out "prefer not to answer" replies
df_survey_subjHelpfulness_responses = df_survey_subjHelpfulness_responses[!df_survey_subjHelpfulness_responses$responseNo==6,]


# treat as numeric to compute stats
df_survey_subjHelpfulness_responses$responseNo=as.numeric(df_survey_subjHelpfulness_responses$responseNo)
# df_survey_subjUsability_responses$responseNo=as.numeric(df_survey_subjUsability_responses$responseNo)

# compute summary stats (mean, sd, sem)
df_survey_subjHelpfulness_summary=data_summary(df_survey_subjHelpfulness_responses, varname="responseNo", 
                    groupnames=c("group"))

# df_survey_subjUsability_summary=data_summary(df_survey_subjUsability_responses, varname="responseNo", 
#                     groupnames=c("group"))

# for plotting:
df_survey_subjHelpUsability_responses = df_survey_item5[!df_survey_item5$checked==0,]
df_survey_subjHelpUsability_responses = df_survey_subjHelpUsability_responses[!df_survey_subjHelpUsability_responses$responseNo==6,]
df_survey_subjHelpUsability_responses$responseNo=as.numeric(df_survey_subjHelpUsability_responses$responseNo)

# plot distribution
item5_figure2_UserResponses_violin = ggplot(df_survey_subjHelpUsability_responses, aes(x=group, y=responseNo, color=group, fill=group)) + 
  geom_violin(scale = "count")+
  geom_boxplot(width=0.1)+
  #geom_jitter(height = 0, width = 0.1)+ # ADD THIS TO DISPLAY INDIVIDUAL DATA POINTS!
  facet_wrap(vars(itemNo),nrow = 1, ncol = 1,labeller=as_labeller(c(`5`="\"Actionability of suggestions.\""))) +
  stat_summary(fun=mean, geom="point", shape=23, size=2, color="red")  +
  labs(x="Group", y = "Response")+
  scale_y_continuous(limits = c(1, 5),breaks=1:5, labels=c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree"))+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=alpha(c(Dcol,Ucol),0.2), labels = c("DiCE","UFCE"))+
  scale_color_manual("Group", values=c(Dcol,Ucol), labels = c("DiCE","UFCE"))+
  theme(plot.title = element_text(hjust = 0.5))

# save
ggsave("Figures/item5_UserResponses_violin.pdf",width = 6, height = 4,)

# Stacked bar plot, the more appropriate visualization for likert data:
# separate "high" and "low" values
lows=likert_item5[as.numeric(likert_item5$responseNo)<4,]
highs=likert_item5[as.numeric(likert_item5$responseNo)>2,]
# NOTE: we take response no 6 out here, after percentages were computed
# THUS, THE RESPONSES WILL NOT SUM UP TO 100% ID PEOPLE CHOSE NOT TO ANSWER!
highs=highs[!highs$responseNo==6,]
  
# divide neutral category by 2 for plotting:
lows$PercUsersChecked[lows$responseNo==3]=lows$PercUsersChecked[lows$responseNo==3]/2
highs$PercUsersChecked[highs$responseNo==3]=highs$PercUsersChecked[highs$responseNo==3]/2

item5_figure2_UserResponses_stackedBar = ggplot() + scale_x_discrete(labels=c("U"="UFCE", "D"="DiCE")) +
  # annotation:
  annotate("rect", xmin = 1.6, xmax = 2.4, ymin = -100, ymax = 100, alpha=0.2, fill = Ucol)+
  # annotate("rect", xmin = 0.6, xmax = 1.4, ymin = -100, ymax = 100, alpha=0.2, fill = Ccol)+
  annotate("rect", xmin = 0.6, xmax = 1.4, ymin = -100, ymax = 100, alpha=0.2, fill = Dcol)+
  # geom_bar, add data high:
  geom_bar(data=highs[order(highs$responseNo, decreasing = F),], aes(x = group, y=PercUsersChecked, fill=responseNo, group=group), position="stack", stat="identity",width = 0.5) +
  # add border for high values:
  stat_summary(data=highs[order(highs$responseNo, decreasing = F),], aes(x = group, y = PercUsersChecked),
               fun = sum,geom = "col",colour = "black",fill=NA,width = 0.5,size=0.1)+
  # geom_bar, add data low:
  geom_bar(data=lows[order(lows$responseNo, decreasing = T),], aes(x = group, y=-PercUsersChecked, fill=responseNo, group=group), position="stack", stat="identity",width = 0.5) +
  # add border for high values:
  stat_summary(data=lows[order(lows$responseNo, decreasing = T),], aes(x = group, y=-PercUsersChecked),
               fun = sum,geom = "col",colour = "black",fill=NA,width = 0.5,size=0.1)+
  # flip coordinates:
  coord_flip(xlim=c(0.99,2.3)) +
  # more aesthetics:
  geom_hline(yintercept = 0, color =c("black"),size=0.1) +
  facet_wrap(vars(itemNo),nrow = 3, ncol = 1,labeller=as_labeller(c(`5`="\"Actionability.\"")))+
  theme_bw(base_size = 10)+
theme(legend.position = "bottom",legend.title=element_blank(),legend.background = element_rect(fill="gray90", size=.5, linetype="dotted"),plot.title = element_text(hjust = 0.5))+
  labs(x="Group", y ="% of users")+
  scale_fill_manual("User response", values = likert_Okabe_Ito_palette,labels = c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree"))+
  scale_color_manual("Group", values=c(Dcol,Ucol), labels = c("DiCE","UFCE"))+
  scale_y_continuous(labels=c(100,50,0,50,100))

# save
ggsave("Figures/item5_UserResponses_stackedBar.pdf",width = 5, height = 3,)
item5_figure2_UserResponses_stackedBar

# show plots
# print("Mean user response for subjective helpfulness / usability:")
# H2.1_figure2_UserResponses_violin
# H2.1_figure2_UserResponses_stackedBar

# # run stats, helpfulness judgements:
item5t="Wilcox"
item5test=uk_wilcox.test(df_survey_subjHelpfulness_responses$responseNo[df_survey_subjHelpfulness_responses$group=="U"],df_survey_subjHelpfulness_responses$responseNo[df_survey_subjHelpfulness_responses$group=="D"],paired=FALSE,exact=FALSE)
item5effsize=item5test$z_val/(sqrt(nrow(df_survey_subjHelpfulness_responses)))
#
matchingRes=paste(matchingRes,paste("\n","H2.1_item_5_6_Userresponses",sep=""),"NA",item5t,item5test$p.value,item5effsize,sep = ",")

# print(item5test$p.value)
# print(item5test$statistic)
# print(item5effsize)
```
The analysis revealed:

* Is there a significant difference in in user responses for the actionability of the explanations? 

We compared responses users in UFCE (M = `r df_survey_subjHelpfulness_summary$mean[df_survey_subjHelpfulness_summary$group=="U"]`, SEM = `r df_survey_subjHelpfulness_summary$sem[df_survey_subjHelpfulness_summary$group=="U"]`) and users in the DiCE (M = `r df_survey_subjHelpfulness_summary$mean[df_survey_subjHelpfulness_summary$group=="D"]`, SEM = `r df_survey_subjHelpfulness_summary$sem[df_survey_subjHelpfulness_summary$group=="D"]`) using a WilcoxonMannWhitney U test. This showed: U=`r item5test$statistic `, p=`r item5test$p.value `, r = `r item5effsize `

```{r echo=FALSE, fig.height = 3, fig.width = 5, fig.align = "center"}
# add significance annotation to likert plots:

anno_df <- data.frame(label = c("*p<0.05", "*p<0.05"),itemNo   = c(5))
item5_figure2_UserResponses_stackedBar_anno = item5_figure2_UserResponses_stackedBar + geom_text(
  data = anno_df, mapping = aes(x = Inf, y = -Inf, label = label), hjust = -0.1, vjust = 1.5, size=2, fontface = "italic")

# save
ggsave("Figures/final/item5_UserResponses_stackedBar_anno_EXP.pdf",width = 5, height = 3,)

# show plots
print("Mean user response for help button and understanding of suggestions:")
item5_figure2_UserResponses_stackedBar_anno

```

## Satisfaction survey items

### Survey item 6 and 7

#### Explanation groups

```{r echo=FALSE, warning=FALSE, fig.height = 5.5, fig.width = 4.5}

# Descriptive stats
# subset to get only relevant data
df_survey_items=df_survey[(df_survey$itemNo==6 | df_survey$itemNo==7) & (!df_survey$group=='C'),]

# set itemNo and responseNo to factors, too
df_survey_items$itemNo=as.factor(df_survey_items$itemNo)
df_survey_items$responseNo=as.factor(df_survey_items$responseNo)

# summary(df_survey_items)

# summarize to get overview values of frequencies and percentages
df_survey_items_summary=dplyr::summarise(group_by(df_survey_items, group, itemNo, responseNo),
          SumChecks=sum(checked),
          PercUsersChecked=100*(sum(checked)/length(unique(userId))))

# display frequency as raw counts
items_p_FreqUserResponses = ggplot(data=df_survey_items_summary, aes(x=responseNo,fill = group)) + 
  geom_bar(aes(y = SumChecks),stat="identity",position = position_dodge(preserve = "single"))+
  facet_wrap(vars(itemNo),nrow = 2, ncol = 1,labeller=as_labeller(c(`6`="\"Suggestions are useful to  increase the fitness of the Shub.\"",`7`="\"I did not use the suggestions.\"")))+
  labs(title="Item 6 and 7 Experimental",x="", y = "Frequency of answer")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Dcol,Ucol), labels = c("DiCE","UFCE"))+
  scale_x_discrete(breaks=1:6, labels=c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree","Prefer not\nto answer"))+
  theme(plot.title = element_text(hjust = 0.5),axis.text.x = element_text(angle = 60,hjust = 0.95))

# display frequency as percentage of all per group users (how many % of explanation users picked plant 1?)
items_p_PercUserResponses = ggplot(data=df_survey_items_summary, aes(x=responseNo,fill = group)) + 
  geom_bar(aes(y = PercUsersChecked),stat="identity",position = position_dodge(preserve = "single"))+
  facet_wrap(vars(itemNo),nrow = 2, ncol = 1,labeller=as_labeller(c(`6`="\"Suggestions are useful to  increase the fitness of the Shub.\"",`7`="\"I did not use the suggestions.\"")))+
  labs(title="Item 6 and 7 Experimental",x="", y = "% of users per group")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Dcol,Ucol), labels = c("DiCE","UFCE"))+
  scale_x_discrete(breaks=1:6, labels=c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree","Prefer not\nto answer"))+
  theme(plot.title = element_text(hjust = 0.5),axis.text.x = element_text(angle = 60,hjust = 0.95))

# safe summary to generate likert plots:
likert_items=df_survey_items_summary

# put all plots together
items_figure1_UserResponses <- ggarrange(items_p_FreqUserResponses,items_p_PercUserResponses,
                    ncol = 1, nrow = 2, heights=c(4,4), common.legend = TRUE)

# save
#ggsave("Figures/item_6_and_7_UserResponses_EXP.pdf",width = 5, height = 6,)

# show
print("Display figures showing user responses in relevant survey items:")
items_figure1_UserResponses

```
On to the statistical comparison: for Likert-scale, we want a non-parametric statistical test for ordinal data, that's the WilcoxonMannWhitney U test.

```{r echo=FALSE, fig.height = 3, fig.width = 5, fig.align = "center"}

# extract response numbers per participant
df_survey_subjHelpfulness_responses = df_survey_items[df_survey_items$itemNo==6,]
df_survey_subjHelpfulness_responses = df_survey_subjHelpfulness_responses[!df_survey_subjHelpfulness_responses$checked==0,]
# take out "prefer not to answer" replies
df_survey_subjHelpfulness_responses = df_survey_subjHelpfulness_responses[!df_survey_subjHelpfulness_responses$responseNo==6,]

df_survey_subjUsability_responses = df_survey_items[df_survey_items$itemNo==7,]
df_survey_subjUsability_responses = df_survey_subjUsability_responses[!df_survey_subjUsability_responses$checked==0,]
# take out "prefer not to answer" replies
df_survey_subjUsability_responses = df_survey_subjUsability_responses[!df_survey_subjUsability_responses$responseNo==6,]

# treat as numeric to compute stats
df_survey_subjHelpfulness_responses$responseNo=as.numeric(df_survey_subjHelpfulness_responses$responseNo)
df_survey_subjUsability_responses$responseNo=as.numeric(df_survey_subjUsability_responses$responseNo)

# compute summary stats (mean, sd, sem)
df_survey_subjHelpfulness_summary=data_summary(df_survey_subjHelpfulness_responses, varname="responseNo", 
                    groupnames=c("group"))

df_survey_subjUsability_summary=data_summary(df_survey_subjUsability_responses, varname="responseNo", 
                    groupnames=c("group"))

# for plotting:
df_survey_subjHelpUsability_responses = df_survey_items[!df_survey_items$checked==0,]
df_survey_subjHelpUsability_responses = df_survey_subjHelpUsability_responses[!df_survey_subjHelpUsability_responses$responseNo==6,]
df_survey_subjHelpUsability_responses$responseNo=as.numeric(df_survey_subjHelpUsability_responses$responseNo)

# plot distribution
H2.1_figure2_UserResponses_violin = ggplot(df_survey_subjHelpUsability_responses, aes(x=group, y=responseNo, color=group, fill=group)) + 
  geom_violin(scale = "count")+
  geom_boxplot(width=0.1)+
  # geom_jitter(height = 0, width = 0.1)+ # ADD THIS TO DISPLAY INDIVIDUAL DATA POINTS!
  facet_wrap(vars(itemNo),nrow = 2, ncol = 1,labeller=as_labeller(c(`6`="\"Suggestions are useful to  increase the fitness of the Shub.\"",`7`="\"I did not use the suggestions.\""))) +
  stat_summary(fun=mean, geom="point", shape=23, size=2, color="red")  +
  labs(x="Group", y = "Response")+
  scale_y_continuous(limits = c(1, 5),breaks=1:5, labels=c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree"))+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=alpha(c(Dcol,Ucol),0.2), labels = c("DiCE","UFCE"))+
  scale_color_manual("Group", values=c(Dcol,Ucol), labels = c("DiCE","UFCE"))+
  theme(plot.title = element_text(hjust = 0.5))

# save
ggsave("Figures/H2.1_item_6_and_7_UserResponses_violin.pdf",width = 6, height = 4,)
H2.1_figure2_UserResponses_violin

# Stacked bar plot, the more appropriate visualization for likert data:
# separate "high" and "low" values
lows=likert_items[as.numeric(likert_items$responseNo)<4,]
highs=likert_items[as.numeric(likert_items$responseNo)>2,]
# NOTE: we take response no 6 out here, after percentages were computed
# THUS, THE RESPONSES WILL NOT SUM UP TO 100% ID PEOPLE CHOSE NOT TO ANSWER!
highs=highs[!highs$responseNo==6,]
  
# divide neutral category by 2 for plotting:
lows$PercUsersChecked[lows$responseNo==3]=lows$PercUsersChecked[lows$responseNo==3]/2
highs$PercUsersChecked[highs$responseNo==3]=highs$PercUsersChecked[highs$responseNo==3]/2

H2.1_figure2_UserResponses_stackedBar = ggplot() + scale_x_discrete(labels=c("U"="UFCE", "D"="DiCE")) +
  # annotation:
  annotate("rect", xmin = 1.6, xmax = 2.4, ymin = -100, ymax = 100, alpha=0.2, fill = Ucol)+
  # annotate("rect", xmin = 0.6, xmax = 1.4, ymin = -100, ymax = 100, alpha=0.2, fill = Ccol)+
  annotate("rect", xmin = 0.6, xmax = 1.4, ymin = -100, ymax = 100, alpha=0.2, fill = Dcol)+
  # geom_bar, add data high:
  geom_bar(data=highs[order(highs$responseNo, decreasing = F),], aes(x = group, y=PercUsersChecked, fill=responseNo, group=group), position="stack", stat="identity",width = 0.5) +
  # add border for high values:
  stat_summary(data=highs[order(highs$responseNo, decreasing = F),], aes(x = group, y = PercUsersChecked),
               fun = sum,geom = "col",colour = "black",fill=NA,width = 0.5,size=0.1)+
  # geom_bar, add data low:
  geom_bar(data=lows[order(lows$responseNo, decreasing = T),], aes(x = group, y=-PercUsersChecked, fill=responseNo, group=group), position="stack", stat="identity",width = 0.5) +
  # add border for high values:
  stat_summary(data=lows[order(lows$responseNo, decreasing = T),], aes(x = group, y=-PercUsersChecked),
               fun = sum,geom = "col",colour = "black",fill=NA,width = 0.5,size=0.1)+
  # flip coordinates:
  coord_flip(xlim=c(0.99,2.3)) +
  # more aesthetics:
  geom_hline(yintercept = 0, color =c("black"),size=0.1) +
  facet_wrap(vars(itemNo),nrow = 3, ncol = 1,labeller=as_labeller(c(`6`="\"Suggestions are useful to  increase the fitness of the Shub.\"",`7`="\"I did not use the suggestions.\"")))+
  theme_bw(base_size = 10)+
theme(legend.position = "bottom",legend.title=element_blank(),legend.background = element_rect(fill="gray90", size=.5, linetype="dotted"),plot.title = element_text(hjust = 0.5))+
  labs(x="Group", y ="% of users")+
  scale_fill_manual("User response", values = likert_Okabe_Ito_palette,labels = c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree"))+
  scale_color_manual("Group", values=c(Dcol,Ucol), labels = c("DiCE","UFCE"))+
  scale_y_continuous(labels=c(100,50,0,50,100))

# save
ggsave("Figures/H2.1_6_and_7_UserResponses_stackedBar_EXP.pdf",width = 6, height = 4,)
H2.1_figure2_UserResponses_stackedBar
# show plots
# print("Mean user response for subjective helpfulness / usability:")
# H2.1_figure2_UserResponses_violin
# H2.1_figure2_UserResponses_stackedBar

# run stats, helpfulness judgements:
item6t="Wilcox"
item6test=uk_wilcox.test(df_survey_subjHelpfulness_responses$responseNo[df_survey_subjHelpfulness_responses$group=="U"],df_survey_subjHelpfulness_responses$responseNo[df_survey_subjHelpfulness_responses$group=="D"],paired=FALSE,exact=FALSE)
item6effsize=item6test$z_val/(sqrt(nrow(df_survey_subjHelpfulness_responses)))

matchingRes=paste(matchingRes,paste("\n","H2.1_item_6_7_Userresponses",sep=""),"NA",item6t,item6test$p.value,item6effsize,sep = ",")

# run stats, usability judgements:
item7t="Wilcox"
item7test=uk_wilcox.test(df_survey_subjUsability_responses$responseNo[df_survey_subjUsability_responses$group=="U"],df_survey_subjUsability_responses$responseNo[df_survey_subjUsability_responses$group=="D"],paired=FALSE,exact=FALSE)
item7effsize=item7test$z_val/(sqrt(nrow(df_survey_subjUsability_responses)))

matchingRes=paste(matchingRes,paste("\n","H2.1_item_6_7_UserResponses",sep=""),"NA",item7t,item7test$p.value,item7effsize,sep = ",")

item6test$p.value
item7test$p.value

```


```{r echo=FALSE, fig.height = 3, fig.width = 5, fig.align = "center"}
# add significance annotation to likert plots:

anno_df <- data.frame(label = c("n.s.(p=0.060)", "*p=<0.05"),itemNo   = c(6, 7))
H2.1_figure2_UserResponses_stackedBar_anno = H2.1_figure2_UserResponses_stackedBar + geom_text(
  data = anno_df, mapping = aes(x = Inf, y = -Inf, label = label), hjust = -0.1, vjust = 1.5, size=2, fontface = "italic")

# save
ggsave("Figures/final/item6_7_figure2_UserResponses_stackedBar_anno.pdf",width = 6, height = 5,)

# show plots
print("Mean user response for item 6 and 7:")
H2.1_figure2_UserResponses_stackedBar_anno

```
The analysis revealed:

* Is there a significant difference in responses regarding the usefulness of suggestions? 

We compared responses of users in UFCE (M = `r df_survey_subjHelpfulness_summary$mean[df_survey_subjHelpfulness_summary$group=="U"]`, SEM = `r df_survey_subjHelpfulness_summary$sem[df_survey_subjHelpfulness_summary$group=="U"]`) and users in the DiCE (M = `r df_survey_subjHelpfulness_summary$mean[df_survey_subjHelpfulness_summary$group=="D"]`, SEM = `r df_survey_subjHelpfulness_summary$sem[df_survey_subjHelpfulness_summary$group=="D"]`) using a WilcoxonMannWhitney U test. This showed: U=`r item6test$statistic `, p=`r item6test$p.value `, r = `r item6effsize `

* Is there a significant difference in the usage of suggestions?: 
We compared responses of users in UFCE (M = `r df_survey_subjUsability_summary$mean[df_survey_subjUsability_summary$group=="U"]`, SEM = `r df_survey_subjUsability_summary$sem[df_survey_subjUsability_summary$group=="U"]`) and users in DiCE (M = `r df_survey_subjUsability_summary$mean[df_survey_subjUsability_summary$group=="D"]`, SEM = `r df_survey_subjUsability_summary$sem[df_survey_subjUsability_summary$group=="D"]`) using a WilcoxonMannWhitney U test. This showed: U=`r item7test$statistic `, p=`r item7test$p.value `, r = `r item7effsize` 


### Survey item 9 and 10

#### Explanation groups

```{r echo=FALSE, warning=FALSE, fig.height = 5.5, fig.width = 4.5}

# Descriptive stats
# subset to get only relevant data
df_survey_items=df_survey[(df_survey$itemNo==9 | df_survey$itemNo==10) & (!df_survey$group=='C'),]

# set itemNo and responseNo to factors, too
df_survey_items$itemNo=as.factor(df_survey_items$itemNo)
df_survey_items$responseNo=as.factor(df_survey_items$responseNo)

# summary(df_survey_items)

# summarize to get overview values of frequencies and percentages
df_survey_items_summary=dplyr::summarise(group_by(df_survey_items, group, itemNo, responseNo),
          SumChecks=sum(checked),
          PercUsersChecked=100*(sum(checked)/length(unique(userId))))

# display frequency as raw counts
items_p_FreqUserResponses = ggplot(data=df_survey_items_summary, aes(x=responseNo,fill = group)) + 
  geom_bar(aes(y = SumChecks),stat="identity",position = position_dodge(preserve = "single"))+
  facet_wrap(vars(itemNo),nrow = 2, ncol = 1,labeller=as_labeller(c(`9`="\"I found inconsistencies in the suggestions.\"",`10`="\"I do not understand how the AlienNutriSolver works.\"")))+
  labs(title="Item 9 and 10 Experimental",x="", y = "Frequency of answer")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Dcol,Ucol), labels = c("DiCE","UFCE"))+
  scale_x_discrete(breaks=1:6, labels=c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree","Prefer not\nto answer"))+
  theme(plot.title = element_text(hjust = 0.5),axis.text.x = element_text(angle = 60,hjust = 0.95))

# display frequency as percentage of all per group users (how many % of explanation users picked plant 1?)
items_p_PercUserResponses = ggplot(data=df_survey_items_summary, aes(x=responseNo,fill = group)) + 
  geom_bar(aes(y = PercUsersChecked),stat="identity",position = position_dodge(preserve = "single"))+
  facet_wrap(vars(itemNo),nrow = 2, ncol = 1,labeller=as_labeller(c(`9`="\"I found inconsistencies in the suggestions.\"",`10`="\"I do not understand how the AlienNutriSolver works.\"")))+
  labs(title="Item 9 and 10 Experimental",x="", y = "% of users per group")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Dcol,Ucol), labels = c("DiCE","UFCE"))+
  scale_x_discrete(breaks=1:6, labels=c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree","Prefer not\nto answer"))+
  theme(plot.title = element_text(hjust = 0.5),axis.text.x = element_text(angle = 60,hjust = 0.95))

# safe summary to generate likert plots:
likert_items=df_survey_items_summary

# put all plots together
items_figure1_UserResponses <- ggarrange(items_p_FreqUserResponses,items_p_PercUserResponses,
                    ncol = 1, nrow = 2, heights=c(4,4), common.legend = TRUE)

# save
ggsave("Figures/item_9_and_10_UserResponses_EXP.pdf",width = 5, height = 6,)

# show
# print("Display figures showing user responses in relevant survey items:")
items_figure1_UserResponses

```
On to the statistical comparison: for Likert-scale, we want a non-parametric statistical test for ordinal data, that's the WilcoxonMannWhitney U test.

```{r echo=FALSE, fig.height = 3, fig.width = 5, fig.align = "center"}

# extract response numbers per participant
df_survey_subjHelpfulness_responses = df_survey_items[df_survey_items$itemNo==9,]
df_survey_subjHelpfulness_responses = df_survey_subjHelpfulness_responses[!df_survey_subjHelpfulness_responses$checked==0,]
# take out "prefer not to answer" replies
df_survey_subjHelpfulness_responses = df_survey_subjHelpfulness_responses[!df_survey_subjHelpfulness_responses$responseNo==6,]

df_survey_subjUsability_responses = df_survey_items[df_survey_items$itemNo==10,]
df_survey_subjUsability_responses = df_survey_subjUsability_responses[!df_survey_subjUsability_responses$checked==0,]
# take out "prefer not to answer" replies
df_survey_subjUsability_responses = df_survey_subjUsability_responses[!df_survey_subjUsability_responses$responseNo==6,]

# treat as numeric to compute stats
df_survey_subjHelpfulness_responses$responseNo=as.numeric(df_survey_subjHelpfulness_responses$responseNo)
df_survey_subjUsability_responses$responseNo=as.numeric(df_survey_subjUsability_responses$responseNo)

# compute summary stats (mean, sd, sem)
df_survey_subjHelpfulness_summary=data_summary(df_survey_subjHelpfulness_responses, varname="responseNo", 
                    groupnames=c("group"))

df_survey_subjUsability_summary=data_summary(df_survey_subjUsability_responses, varname="responseNo", 
                    groupnames=c("group"))

# for plotting:
df_survey_subjHelpUsability_responses = df_survey_items[!df_survey_items$checked==0,]
df_survey_subjHelpUsability_responses = df_survey_subjHelpUsability_responses[!df_survey_subjHelpUsability_responses$responseNo==6,]
df_survey_subjHelpUsability_responses$responseNo=as.numeric(df_survey_subjHelpUsability_responses$responseNo)

# plot distribution
H2.1_figure2_UserResponses_violin = ggplot(df_survey_subjHelpUsability_responses, aes(x=group, y=responseNo, color=group, fill=group)) + 
  geom_violin(scale = "count")+
  geom_boxplot(width=0.1)+
  # geom_jitter(height = 0, width = 0.1)+ # ADD THIS TO DISPLAY INDIVIDUAL DATA POINTS!
  facet_wrap(vars(itemNo),nrow = 2, ncol = 1,labeller=as_labeller(c(`9`="\"I found inconsistencies in the suggestions.\"",`10`="\"I do not understand how the AlienNutriSolver works.\""))) +
  stat_summary(fun=mean, geom="point", shape=23, size=2, color="red")  +
  labs(x="Group", y = "Response")+
  scale_y_continuous(limits = c(1, 5),breaks=1:5, labels=c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree"))+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=alpha(c(Dcol,Ucol),0.2), labels = c("DiCE","UFCE"))+
  scale_color_manual("Group", values=c(Dcol,Ucol), labels = c("DiCE","UFCE"))+
  theme(plot.title = element_text(hjust = 0.5))

# save
ggsave("Figures/H2.1_item_9_and_10_UserResponses_violin.pdf",width = 6, height = 4,)
H2.1_figure2_UserResponses_violin

# Stacked bar plot, the more appropriate visualization for likert data:
# separate "high" and "low" values
lows=likert_items[as.numeric(likert_items$responseNo)<4,]
highs=likert_items[as.numeric(likert_items$responseNo)>2,]
# NOTE: we take response no 6 out here, after percentages were computed
# THUS, THE RESPONSES WILL NOT SUM UP TO 100% ID PEOPLE CHOSE NOT TO ANSWER!
highs=highs[!highs$responseNo==6,]
  
# divide neutral category by 2 for plotting:
lows$PercUsersChecked[lows$responseNo==3]=lows$PercUsersChecked[lows$responseNo==3]/2
highs$PercUsersChecked[highs$responseNo==3]=highs$PercUsersChecked[highs$responseNo==3]/2

H2.1_figure2_UserResponses_stackedBar = ggplot() + scale_x_discrete(labels=c("U"="UFCE", "D"="DiCE")) +
  # annotation:
  annotate("rect", xmin = 1.6, xmax = 2.4, ymin = -100, ymax = 100, alpha=0.2, fill = Ucol)+
  # annotate("rect", xmin = 0.6, xmax = 1.4, ymin = -100, ymax = 100, alpha=0.2, fill = Ccol)+
  annotate("rect", xmin = 0.6, xmax = 1.4, ymin = -100, ymax = 100, alpha=0.2, fill = Dcol)+
  # geom_bar, add data high:
  geom_bar(data=highs[order(highs$responseNo, decreasing = F),], aes(x = group, y=PercUsersChecked, fill=responseNo, group=group), position="stack", stat="identity",width = 0.5) +
  # add border for high values:
  stat_summary(data=highs[order(highs$responseNo, decreasing = F),], aes(x = group, y = PercUsersChecked),
               fun = sum,geom = "col",colour = "black",fill=NA,width = 0.5,size=0.1)+
  # geom_bar, add data low:
  geom_bar(data=lows[order(lows$responseNo, decreasing = T),], aes(x = group, y=-PercUsersChecked, fill=responseNo, group=group), position="stack", stat="identity",width = 0.5) +
  # add border for high values:
  stat_summary(data=lows[order(lows$responseNo, decreasing = T),], aes(x = group, y=-PercUsersChecked),
               fun = sum,geom = "col",colour = "black",fill=NA,width = 0.5,size=0.1)+
  # flip coordinates:
  coord_flip(xlim=c(0.99,2.3)) +
  # more aesthetics:
  geom_hline(yintercept = 0, color =c("black"),size=0.1) +
  facet_wrap(vars(itemNo),nrow = 3, ncol = 1,labeller=as_labeller(c(`9`="\"I found inconsistencies in the suggestions.\"",`10`="\"I do not understand how the AlienNutriSolver works.\"")))+
  theme_bw(base_size = 10)+
theme(legend.position = "bottom",legend.title=element_blank(),legend.background = element_rect(fill="gray90", size=.5, linetype="dotted"),plot.title = element_text(hjust = 0.5))+
  labs(x="Group", y ="% of users")+
  scale_fill_manual("User response", values = likert_Okabe_Ito_palette,labels = c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree"))+
  scale_color_manual("Group", values=c(Dcol,Ucol), labels = c("DiCE","UFCE"))+
  scale_y_continuous(labels=c(100,50,0,50,100))

# save
ggsave("Figures/H2.1_9_and_10_UserResponses_stackedBar_EXP.pdf",width = 6, height = 4,)
H2.1_figure2_UserResponses_stackedBar
# show plots
# print("Mean user response for subjective helpfulness / usability:")
# H2.1_figure2_UserResponses_violin
# H2.1_figure2_UserResponses_stackedBar

# run stats, helpfulness judgements:
item9t="Wilcox"
item9test=uk_wilcox.test(df_survey_subjHelpfulness_responses$responseNo[df_survey_subjHelpfulness_responses$group=="U"],df_survey_subjHelpfulness_responses$responseNo[df_survey_subjHelpfulness_responses$group=="D"],paired=FALSE,exact=FALSE)
item9effsize=item9test$z_val/(sqrt(nrow(df_survey_subjHelpfulness_responses)))

matchingRes=paste(matchingRes,paste("\n","H2.1_item_9_10_Userresponses",sep=""),"NA",item9t,item9test$p.value,item9effsize,sep = ",")

# run stats, usability judgements:
item10t="Wilcox"
item10test=uk_wilcox.test(df_survey_subjUsability_responses$responseNo[df_survey_subjUsability_responses$group=="U"],df_survey_subjUsability_responses$responseNo[df_survey_subjUsability_responses$group=="D"],paired=FALSE,exact=FALSE)
item10effsize=item10test$z_val/(sqrt(nrow(df_survey_subjUsability_responses)))

matchingRes=paste(matchingRes,paste("\n","H2.1_item_9_10_UserResponses",sep=""),"NA",item10t,item10test$p.value,item10effsize,sep = ",")

item9test$p.value
item10test$p.value

```



```{r echo=FALSE, fig.height = 3, fig.width = 5, fig.align = "center"}
# add significance annotation to likert plots:

anno_df <- data.frame(label = c("n.s.(p=0.200)", "n.s.(p=0.076)"),itemNo   = c(9, 10))
H2.1_figure2_UserResponses_stackedBar_anno = H2.1_figure2_UserResponses_stackedBar + geom_text(
  data = anno_df, mapping = aes(x = Inf, y = -Inf, label = label), hjust = -0.1, vjust = 1.5, size=2, fontface = "italic")

# save
ggsave("Figures/final/item9_10_UserResponses_stackedBar_anno.pdf",width = 6, height = 5,)

# show plots
# print("Mean user response for item 9 and 10:")
H2.1_figure2_UserResponses_stackedBar_anno

```

The analysis revealed:

* Is there a significant difference in responses to find inconsistencies in suggestions? 

We compared responses of users in UFCE (M = `r df_survey_subjHelpfulness_summary$mean[df_survey_subjHelpfulness_summary$group=="U"]`, SEM = `r df_survey_subjHelpfulness_summary$sem[df_survey_subjHelpfulness_summary$group=="U"]`) and users in the DiCE (M = `r df_survey_subjHelpfulness_summary$mean[df_survey_subjHelpfulness_summary$group=="D"]`, SEM = `r df_survey_subjHelpfulness_summary$sem[df_survey_subjHelpfulness_summary$group=="D"]`) using a WilcoxonMannWhitney U test. This showed: U=`r item9test$statistic `, p=`r item9test$p.value `, r = `r item9effsize `

* Is there a significant in responses that user dont understand how Alie Nutri-solver works?: 
We compared responses of users in UFCE (M = `r df_survey_subjUsability_summary$mean[df_survey_subjUsability_summary$group=="U"]`, SEM = `r df_survey_subjUsability_summary$sem[df_survey_subjUsability_summary$group=="U"]`) and users in DiCE (M = `r df_survey_subjUsability_summary$mean[df_survey_subjUsability_summary$group=="D"]`, SEM = `r df_survey_subjUsability_summary$sem[df_survey_subjUsability_summary$group=="D"]`) using a WilcoxonMannWhitney U test. This showed: U=`r item10test$statistic `, p=`r item10test$p.value `, r = `r item10effsize`



#### Control group (item 9 and 10  -> 6 and 7)

```{r echo=FALSE, warning=FALSE, fig.height = 5.5, fig.width = 4.5}

# Descriptive stats
# subset to get only relevant data
df_survey_items=df_survey[(df_survey$itemNo==6 | df_survey$itemNo==7) & (df_survey$group=='C'),]

# set itemNo and responseNo to factors, too
df_survey_items$itemNo=as.factor(df_survey_items$itemNo)
df_survey_items$responseNo=as.factor(df_survey_items$responseNo)

# summary(df_survey_items)

# summarize to get overview values of frequencies and percentages
df_survey_items_summary=dplyr::summarise(group_by(df_survey_items, group, itemNo, responseNo),
          SumChecks=sum(checked),
          PercUsersChecked=100*(sum(checked)/length(unique(userId))))

# display frequency as raw counts
items_p_FreqUserResponses = ggplot(data=df_survey_items_summary, aes(x=responseNo,fill = group)) + 
  geom_bar(aes(y = SumChecks),stat="identity",position = position_dodge(preserve = "single"))+
  facet_wrap(vars(itemNo),nrow = 2, ncol = 1,labeller=as_labeller(c(`6`="\"I found inconsistencies in the behavior of the AlienNutriSolver.\"",`7`="\"I do not understand how the AlienNutriSolver works.\"")))+
  labs(x="", y = "Frequency of answer")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Ccol), labels = c("Control"))+
  scale_x_discrete(breaks=1:6, labels=c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree","Prefer not\nto answer"))+
  theme(plot.title = element_text(hjust = 0.5),axis.text.x = element_text(angle = 60,hjust = 0.95))

# display frequency as percentage of all per group users (how many % of explanation users picked plant 1?)
items_p_PercUserResponses = ggplot(data=df_survey_items_summary, aes(x=responseNo,fill = group)) + 
  geom_bar(aes(y = PercUsersChecked),stat="identity",position = position_dodge(preserve = "single"))+
  facet_wrap(vars(itemNo),nrow = 2, ncol = 1,labeller=as_labeller(c(`9`="\"I found inconsistencies in the behavior of the AlienNutriSolver.\"",`10`="\"I do not understand how the AlienNutriSolver works.\"")))+
  labs(title="Item 6 and 7 Control",x="", y = "% of users per group")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Ccol), labels = c("Control"))+
  scale_x_discrete(breaks=1:6, labels=c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree","Prefer not\nto answer"))+
  theme(plot.title = element_text(hjust = 0.5),axis.text.x = element_text(angle = 60,hjust = 0.95))

# safe summary to generate likert plots:
likert_items=df_survey_items_summary

# put all plots together
items_figure1_UserResponses <- ggarrange(items_p_FreqUserResponses,items_p_PercUserResponses,
                    ncol = 1, nrow = 2, heights=c(4,4), common.legend = TRUE)

# save
ggsave("Figures/item_6_and_7_UserResponses_control.pdf",width = 5, height = 6,)

# show
# print("Display figures showing user responses in relevant survey items:")
items_figure1_UserResponses

```
On to the statistical comparison: for Likert-scale, we want a non-parametric statistical test for ordinal data, that's the WilcoxonMannWhitney U test.

```{r echo=FALSE, fig.height = 3, fig.width = 5, fig.align = "center"}

# extract response numbers per participant
df_survey_subjHelpfulness_responses = df_survey_items[df_survey_items$itemNo==6,]
df_survey_subjHelpfulness_responses = df_survey_subjHelpfulness_responses[!df_survey_subjHelpfulness_responses$checked==0,]
# take out "prefer not to answer" replies
df_survey_subjHelpfulness_responses = df_survey_subjHelpfulness_responses[!df_survey_subjHelpfulness_responses$responseNo==6,]

df_survey_subjUsability_responses = df_survey_items[df_survey_items$itemNo==7,]
df_survey_subjUsability_responses = df_survey_subjUsability_responses[!df_survey_subjUsability_responses$checked==0,]
# take out "prefer not to answer" replies
df_survey_subjUsability_responses = df_survey_subjUsability_responses[!df_survey_subjUsability_responses$responseNo==6,]

# treat as numeric to compute stats
df_survey_subjHelpfulness_responses$responseNo=as.numeric(df_survey_subjHelpfulness_responses$responseNo)
df_survey_subjUsability_responses$responseNo=as.numeric(df_survey_subjUsability_responses$responseNo)

# compute summary stats (mean, sd, sem)
df_survey_subjHelpfulness_summary=data_summary(df_survey_subjHelpfulness_responses, varname="responseNo", 
                    groupnames=c("group"))

df_survey_subjUsability_summary=data_summary(df_survey_subjUsability_responses, varname="responseNo", 
                    groupnames=c("group"))

# for plotting:
df_survey_subjHelpUsability_responses = df_survey_items[!df_survey_items$checked==0,]
df_survey_subjHelpUsability_responses = df_survey_subjHelpUsability_responses[!df_survey_subjHelpUsability_responses$responseNo==6,]
df_survey_subjHelpUsability_responses$responseNo=as.numeric(df_survey_subjHelpUsability_responses$responseNo)

# plot distribution
H2.1_figure2_UserResponses_violin = ggplot(df_survey_subjHelpUsability_responses, aes(x=group, y=responseNo, color=group, fill=group)) + 
  geom_violin(scale = "count")+
  geom_boxplot(width=0.1)+
  # geom_jitter(height = 0, width = 0.1)+ # ADD THIS TO DISPLAY INDIVIDUAL DATA POINTS!
  facet_wrap(vars(itemNo),nrow = 2, ncol = 1,labeller=as_labeller(c(`6`="\"I found inconsistencies in the behavior of the AlienNutriSolver.\"",`7`="\"I do not understand how the AlienNutriSolver works..\""))) +
  stat_summary(fun=mean, geom="point", shape=23, size=2, color="red")  +
  labs(title="Mean response for control items 6 and 7",x="Group", y = "Response")+
  scale_y_continuous(limits = c(1, 5),breaks=1:5, labels=c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree"))+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=alpha(c(Ccol),0.2), labels = c("Control"))+
  scale_color_manual("Group", values=c(Dcol,Ucol), labels = c("Control"))+
  theme(plot.title = element_text(hjust = 0.5))

# save
ggsave("Figures/H2.1_item_6_and_7_UserResponses_violin_control.pdf",width = 6, height = 4,)
H2.1_figure2_UserResponses_violin

# Stacked bar plot, the more appropriate visualization for likert data:
# separate "high" and "low" values
lows=likert_items[as.numeric(likert_items$responseNo)<4,]
highs=likert_items[as.numeric(likert_items$responseNo)>2,]
# NOTE: we take response no 6 out here, after percentages were computed
# THUS, THE RESPONSES WILL NOT SUM UP TO 100% ID PEOPLE CHOSE NOT TO ANSWER!
highs=highs[!highs$responseNo==6,]
  
# divide neutral category by 2 for plotting:
lows$PercUsersChecked[lows$responseNo==3]=lows$PercUsersChecked[lows$responseNo==3]/2
highs$PercUsersChecked[highs$responseNo==3]=highs$PercUsersChecked[highs$responseNo==3]/2

H2.1_figure2_UserResponses_stackedBar = ggplot() + scale_x_discrete(labels=c("C"="Control")) +
  # annotation:
  # annotate("rect", xmin = 1.6, xmax = 2.4, ymin = -100, ymax = 100, alpha=0.2, fill = Ucol)+
  annotate("rect", xmin = 0.6, xmax = 1.4, ymin = -100, ymax = 100, alpha=0.2, fill = Ccol)+
  # annotate("rect", xmin = 0.6, xmax = 1.4, ymin = -100, ymax = 100, alpha=0.2, fill = Dcol)+
  # geom_bar, add data high:
  geom_bar(data=highs[order(highs$responseNo, decreasing = F),], aes(x = group, y=PercUsersChecked, fill=responseNo, group=group), position="stack", stat="identity",width = 0.5) +
  # add border for high values:
  stat_summary(data=highs[order(highs$responseNo, decreasing = F),], aes(x = group, y = PercUsersChecked),
               fun = sum,geom = "col",colour = "black",fill=NA,width = 0.5,size=0.1)+
  # geom_bar, add data low:
  geom_bar(data=lows[order(lows$responseNo, decreasing = T),], aes(x = group, y=-PercUsersChecked, fill=responseNo, group=group), position="stack", stat="identity",width = 0.5) +
  # add border for high values:
  stat_summary(data=lows[order(lows$responseNo, decreasing = T),], aes(x = group, y=-PercUsersChecked),
               fun = sum,geom = "col",colour = "black",fill=NA,width = 0.5,size=0.1)+
  # flip coordinates:
  coord_flip(xlim=c(0.99,2.3)) +
  # more aesthetics:
  geom_hline(yintercept = 0, color =c("black"),size=0.1) +
  facet_wrap(vars(itemNo),nrow = 3, ncol = 1,labeller=as_labeller(c(`6`="\"I found inconsistencies in the behavior of the AlienNutriSolver.\"",`7`="\" I do not understand how the AlienNutriSolver works.\"")))+
  theme_bw(base_size = 10)+
theme(legend.position = "bottom",legend.title=element_blank(),legend.background = element_rect(fill="gray90", size=.5, linetype="dotted"),plot.title = element_text(hjust = 0.5))+
  labs(title="",x="Group", y ="% of users")+
  scale_fill_manual("User response", values = likert_Okabe_Ito_palette,labels = c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree"))+
  scale_color_manual("Group", values=c(Ccol), labels = c("Control"))+
  scale_y_continuous(labels=c(100,50,0,50,100))

# save
ggsave("Figures/final/item6_7_9_10_UserResponses_stackedBar_control.pdf",width = 6, height = 4,)
H2.1_figure2_UserResponses_stackedBar
# show plots
# print("Mean user response for subjective helpfulness / usability:")
# H2.1_figure2_UserResponses_violin
# H2.1_figure2_UserResponses_stackedBar

# # run stats, helpfulness judgements:
# item3t="Wilcox"
# item3test=uk_wilcox.test(df_survey_subjHelpfulness_responses$responseNo[df_survey_subjHelpfulness_responses$group=="U"],df_survey_subjHelpfulness_responses$responseNo[df_survey_subjHelpfulness_responses$group=="D"],paired=FALSE,exact=FALSE)
# item3effsize=item3test$z_val/(sqrt(nrow(df_survey_subjHelpfulness_responses)))
# 
# matchingRes=paste(matchingRes,paste("\n","H2.1_item_3_4_Userresponses",sep=""),"NA",item3t,item3test$p.value,item3effsize,sep = ",")
# 
# # run stats, usability judgements:
# item4t="Wilcox"
# item4test=uk_wilcox.test(df_survey_subjUsability_responses$responseNo[df_survey_subjUsability_responses$group=="U"],df_survey_subjUsability_responses$responseNo[df_survey_subjUsability_responses$group=="D"],paired=FALSE,exact=FALSE)
# item4effsize=item4test$z_val/(sqrt(nrow(df_survey_subjUsability_responses)))
# 
# matchingRes=paste(matchingRes,paste("\n","H2.1_item_3_4_UserResponses",sep=""),"NA",item4t,item4test$p.value,item4effsize,sep = ",")
# 
# print(item5test$p.value)

```

#### survey item 11 and 12

#### Explanation groups

```{r echo=FALSE, warning=FALSE, fig.height = 5.5, fig.width = 4.5}

# Descriptive stats
# subset to get only relevant data
df_survey_items=df_survey[(df_survey$itemNo==11 | df_survey$itemNo==12) & (!df_survey$group=='C'),]

# set itemNo and responseNo to factors, too
df_survey_items$itemNo=as.factor(df_survey_items$itemNo)
df_survey_items$responseNo=as.factor(df_survey_items$responseNo)

# summary(df_survey_items)

# summarize to get overview values of frequencies and percentages
df_survey_items_summary=dplyr::summarise(group_by(df_survey_items, group, itemNo, responseNo),
          SumChecks=sum(checked),
          PercUsersChecked=100*(sum(checked)/length(unique(userId))))

# display frequency as raw counts
items_p_FreqUserResponses = ggplot(data=df_survey_items_summary, aes(x=responseNo,fill = group)) + 
  geom_bar(aes(y = SumChecks),stat="identity",position = position_dodge(preserve = "single"))+
  facet_wrap(vars(itemNo),nrow = 2, ncol = 1,labeller=as_labeller(c(`11`="\"Suggestion provided by the Help button are satisfying.\"",`12`="\"Suggestions provided by the Help button have sufficient detail.\"")))+
  labs(title="Item 11 and 12 Experimental",x="", y = "Frequency of answer")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Dcol,Ucol), labels = c("DiCE","UFCE"))+
  scale_x_discrete(breaks=1:6, labels=c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree","Prefer not\nto answer"))+
  theme(plot.title = element_text(hjust = 0.5),axis.text.x = element_text(angle = 60,hjust = 0.95))

# display frequency as percentage of all per group users (how many % of explanation users picked plant 1?)
items_p_PercUserResponses = ggplot(data=df_survey_items_summary, aes(x=responseNo,fill = group)) + 
  geom_bar(aes(y = PercUsersChecked),stat="identity",position = position_dodge(preserve = "single"))+
  facet_wrap(vars(itemNo),nrow = 2, ncol = 1,labeller=as_labeller(c(`11`="\"Suggestion provided by the Help button are satisfying.\"",`12`="\"Suggestions provided by the Help button have sufficient detail.\"")))+
  labs(title="Item 11 and 12 Experimental",x="", y = "% of users per group")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Dcol,Ucol), labels = c("DiCE","UFCE"))+
  scale_x_discrete(breaks=1:6, labels=c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree","Prefer not\nto answer"))+
  theme(plot.title = element_text(hjust = 0.5),axis.text.x = element_text(angle = 60,hjust = 0.95))

# safe summary to generate likert plots:
likert_items=df_survey_items_summary

# put all plots together
items_figure1_UserResponses <- ggarrange(items_p_FreqUserResponses,items_p_PercUserResponses,
                    ncol = 1, nrow = 2, heights=c(4,4), common.legend = TRUE)

# save
ggsave("Figures/item_11_and_12_UserResponses_EXP.pdf",width = 5, height = 6,)

# show
# print("Display figures showing user responses in relevant survey items:")
items_figure1_UserResponses

```
On to the statistical comparison: for Likert-scale, we want a non-parametric statistical test for ordinal data, that's the WilcoxonMannWhitney U test.

```{r echo=FALSE, fig.height = 3, fig.width = 5, fig.align = "center"}

# extract response numbers per participant
df_survey_subjHelpfulness_responses = df_survey_items[df_survey_items$itemNo==11,]
df_survey_subjHelpfulness_responses = df_survey_subjHelpfulness_responses[!df_survey_subjHelpfulness_responses$checked==0,]
# take out "prefer not to answer" replies
df_survey_subjHelpfulness_responses = df_survey_subjHelpfulness_responses[!df_survey_subjHelpfulness_responses$responseNo==6,]

df_survey_subjUsability_responses = df_survey_items[df_survey_items$itemNo==12,]
df_survey_subjUsability_responses = df_survey_subjUsability_responses[!df_survey_subjUsability_responses$checked==0,]
# take out "prefer not to answer" replies
df_survey_subjUsability_responses = df_survey_subjUsability_responses[!df_survey_subjUsability_responses$responseNo==6,]

# treat as numeric to compute stats
df_survey_subjHelpfulness_responses$responseNo=as.numeric(df_survey_subjHelpfulness_responses$responseNo)
df_survey_subjUsability_responses$responseNo=as.numeric(df_survey_subjUsability_responses$responseNo)

# compute summary stats (mean, sd, sem)
df_survey_subjHelpfulness_summary=data_summary(df_survey_subjHelpfulness_responses, varname="responseNo", 
                    groupnames=c("group"))

df_survey_subjUsability_summary=data_summary(df_survey_subjUsability_responses, varname="responseNo", 
                    groupnames=c("group"))

# for plotting:
df_survey_subjHelpUsability_responses = df_survey_items[!df_survey_items$checked==0,]
df_survey_subjHelpUsability_responses = df_survey_subjHelpUsability_responses[!df_survey_subjHelpUsability_responses$responseNo==6,]
df_survey_subjHelpUsability_responses$responseNo=as.numeric(df_survey_subjHelpUsability_responses$responseNo)

# plot distribution
H2.1_figure2_UserResponses_violin = ggplot(df_survey_subjHelpUsability_responses, aes(x=group, y=responseNo, color=group, fill=group)) + 
  geom_violin(scale = "count")+
  geom_boxplot(width=0.1)+
  # geom_jitter(height = 0, width = 0.1)+ # ADD THIS TO DISPLAY INDIVIDUAL DATA POINTS!
  facet_wrap(vars(itemNo),nrow = 2, ncol = 1,labeller=as_labeller(c(`11`="\"Suggestion provided by the Help button are satisfying.\"",`12`="\"Suggestion provided by the Help button have sufficient details.\""))) +
  stat_summary(fun=mean, geom="point", shape=23, size=2, color="red")  +
  labs(title="Mean response for item 11 and 12",x="Group", y = "Response")+
  scale_y_continuous(limits = c(1, 5),breaks=1:5, labels=c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree"))+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=alpha(c(Dcol,Ucol),0.2), labels = c("DiCE","UFCE"))+
  scale_color_manual("Group", values=c(Dcol,Ucol), labels = c("DiCE","UFCE"))+
  theme(plot.title = element_text(hjust = 0.5))

# save
ggsave("Figures/H2.1_item_11_and_12_UserResponses_violin.pdf",width = 6, height = 4,)
H2.1_figure2_UserResponses_violin

# Stacked bar plot, the more appropriate visualization for likert data:
# separate "high" and "low" values
lows=likert_items[as.numeric(likert_items$responseNo)<4,]
highs=likert_items[as.numeric(likert_items$responseNo)>2,]
# NOTE: we take response no 6 out here, after percentages were computed
# THUS, THE RESPONSES WILL NOT SUM UP TO 100% ID PEOPLE CHOSE NOT TO ANSWER!
highs=highs[!highs$responseNo==6,]
  
# divide neutral category by 2 for plotting:
lows$PercUsersChecked[lows$responseNo==3]=lows$PercUsersChecked[lows$responseNo==3]/2
highs$PercUsersChecked[highs$responseNo==3]=highs$PercUsersChecked[highs$responseNo==3]/2

H2.1_figure2_UserResponses_stackedBar = ggplot() + scale_x_discrete(labels=c("U"="UFCE", "D"="DiCE")) +
  # annotation:
  annotate("rect", xmin = 1.6, xmax = 2.4, ymin = -100, ymax = 100, alpha=0.2, fill = Ucol)+
  # annotate("rect", xmin = 0.6, xmax = 1.4, ymin = -100, ymax = 100, alpha=0.2, fill = Ccol)+
  annotate("rect", xmin = 0.6, xmax = 1.4, ymin = -100, ymax = 100, alpha=0.2, fill = Dcol)+
  # geom_bar, add data high:
  geom_bar(data=highs[order(highs$responseNo, decreasing = F),], aes(x = group, y=PercUsersChecked, fill=responseNo, group=group), position="stack", stat="identity",width = 0.5) +
  # add border for high values:
  stat_summary(data=highs[order(highs$responseNo, decreasing = F),], aes(x = group, y = PercUsersChecked),
               fun = sum,geom = "col",colour = "black",fill=NA,width = 0.5,size=0.1)+
  # geom_bar, add data low:
  geom_bar(data=lows[order(lows$responseNo, decreasing = T),], aes(x = group, y=-PercUsersChecked, fill=responseNo, group=group), position="stack", stat="identity",width = 0.5) +
  # add border for high values:
  stat_summary(data=lows[order(lows$responseNo, decreasing = T),], aes(x = group, y=-PercUsersChecked),
               fun = sum,geom = "col",colour = "black",fill=NA,width = 0.5,size=0.1)+
  # flip coordinates:
  coord_flip(xlim=c(0.99,2.3)) +
  # more aesthetics:
  geom_hline(yintercept = 0, color =c("black"),size=0.1) +
  facet_wrap(vars(itemNo),nrow = 3, ncol = 1,labeller=as_labeller(c(`11`="\"Suggestion provided by the Help button are satisfying.\"",`12`="\"Suggestion provided by the Help button have sufficient detail.\"")))+
  theme_bw(base_size = 10)+
theme(legend.position = "bottom",legend.title=element_blank(),legend.background = element_rect(fill="gray90", size=.5, linetype="dotted"),plot.title = element_text(hjust = 0.5))+
  labs(x="Group", y ="% of users")+
  scale_fill_manual("User response", values = likert_Okabe_Ito_palette,labels = c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree"))+
  scale_color_manual("Group", values=c(Dcol,Ucol), labels = c("DiCE","UFCE"))+
  scale_y_continuous(labels=c(100,50,0,50,100))

# save
ggsave("Figures/H2.1_11_and_12_UserResponses_stackedBar_EXP.pdf",width = 6, height = 4,)
H2.1_figure2_UserResponses_stackedBar
# show plots
# print("Mean user response for subjective helpfulness / usability:")
# H2.1_figure2_UserResponses_violin
# H2.1_figure2_UserResponses_stackedBar

# run stats, helpfulness judgements:
item11t="Wilcox"
item11test=uk_wilcox.test(df_survey_subjHelpfulness_responses$responseNo[df_survey_subjHelpfulness_responses$group=="U"],df_survey_subjHelpfulness_responses$responseNo[df_survey_subjHelpfulness_responses$group=="D"],paired=FALSE,exact=FALSE)
item11effsize=item11test$z_val/(sqrt(nrow(df_survey_subjHelpfulness_responses)))

matchingRes=paste(matchingRes,paste("\n","H2.1_item_11_12_Userresponses",sep=""),"NA",item11t,item11test$p.value,item11effsize,sep = ",")

# run stats, usability judgements:
item12t="Wilcox"
item12test=uk_wilcox.test(df_survey_subjUsability_responses$responseNo[df_survey_subjUsability_responses$group=="U"],df_survey_subjUsability_responses$responseNo[df_survey_subjUsability_responses$group=="D"],paired=FALSE,exact=FALSE)
item12effsize=item12test$z_val/(sqrt(nrow(df_survey_subjUsability_responses)))

matchingRes=paste(matchingRes,paste("\n","H2.1_item_11_12_UserResponses",sep=""),"NA",item11t,item12test$p.value,item12effsize,sep = ",")

print(item11test$p.value)
print(item12test$p.value)

```




```{r echo=FALSE, fig.height = 3, fig.width = 5, fig.align = "center"}
# add significance annotation to likert plots:

anno_df <- data.frame(label = c("n.s.(p=0.131)", "n.s.(p=0.320)"),itemNo   = c(11, 12))
H2.1_figure2_UserResponses_stackedBar_anno = H2.1_figure2_UserResponses_stackedBar + geom_text(
  data = anno_df, mapping = aes(x = Inf, y = -Inf, label = label), hjust = -0.1, vjust = 1.5, size=2, fontface = "italic")

# save
ggsave("Figures/final/item11_12_UserResponses_stackedBar_anno.pdf",width = 6, height = 5,)

# show plots
# print("Mean user response for item 11 and 12:")
H2.1_figure2_UserResponses_stackedBar_anno

```

The analysis revealed:

* Is there a significant difference in responses that suggestions are satisfying? 

We compared responses of users in UFCE (M = `r df_survey_subjHelpfulness_summary$mean[df_survey_subjHelpfulness_summary$group=="U"]`, SEM = `r df_survey_subjHelpfulness_summary$sem[df_survey_subjHelpfulness_summary$group=="U"]`) and users in the DiCE (M = `r df_survey_subjHelpfulness_summary$mean[df_survey_subjHelpfulness_summary$group=="D"]`, SEM = `r df_survey_subjHelpfulness_summary$sem[df_survey_subjHelpfulness_summary$group=="D"]`) using a WilcoxonMannWhitney U test. This showed: U=`r item11test$statistic `, p=`r item11test$p.value `, r = `r item11effsize `

* Is there a significant difference in responses that suggestions have sifficient details?: 
We compared responses of users in UFCE (M = `r df_survey_subjUsability_summary$mean[df_survey_subjUsability_summary$group=="U"]`, SEM = `r df_survey_subjUsability_summary$sem[df_survey_subjUsability_summary$group=="U"]`) and users in DiCE (M = `r df_survey_subjUsability_summary$mean[df_survey_subjUsability_summary$group=="D"]`, SEM = `r df_survey_subjUsability_summary$sem[df_survey_subjUsability_summary$group=="D"]`) using a WilcoxonMannWhitney U test. This showed: U=`r item12test$statistic `, p=`r item12test$p.value `, r = `r item12effsize`


#### survey item 13 and 14

#### Explanation groups

```{r echo=FALSE, warning=FALSE, fig.height = 5.5, fig.width = 4.5}

# Descriptive stats
# subset to get only relevant data
df_survey_items=df_survey[(df_survey$itemNo==13 | df_survey$itemNo==14) & (!df_survey$group=='C'),]

# set itemNo and responseNo to factors, too
df_survey_items$itemNo=as.factor(df_survey_items$itemNo)
df_survey_items$responseNo=as.factor(df_survey_items$responseNo)

# summary(df_survey_items)

# summarize to get overview values of frequencies and percentages
df_survey_items_summary=dplyr::summarise(group_by(df_survey_items, group, itemNo, responseNo),
          SumChecks=sum(checked),
          PercUsersChecked=100*(sum(checked)/length(unique(userId))))

# display frequency as raw counts
items_p_FreqUserResponses = ggplot(data=df_survey_items_summary, aes(x=responseNo,fill = group)) + 
  geom_bar(aes(y = SumChecks),stat="identity",position = position_dodge(preserve = "single"))+
  facet_wrap(vars(itemNo),nrow = 2, ncol = 1,labeller=as_labeller(c(`13`="\"Suggestion provided by the Help button seem incomplete.\"",`14`="\"Suggestions tell me how to use the AlienNutriSolver.\"")))+
  labs(title="Item 13 and 14 Experimental",x="", y = "Frequency of answer")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Dcol,Ucol), labels = c("DiCE","UFCE"))+
  scale_x_discrete(breaks=1:6, labels=c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree","Prefer not\nto answer"))+
  theme(plot.title = element_text(hjust = 0.5),axis.text.x = element_text(angle = 60,hjust = 0.95))

# display frequency as percentage of all per group users (how many % of explanation users picked plant 1?)
items_p_PercUserResponses = ggplot(data=df_survey_items_summary, aes(x=responseNo,fill = group)) + 
  geom_bar(aes(y = PercUsersChecked),stat="identity",position = position_dodge(preserve = "single"))+
  facet_wrap(vars(itemNo),nrow = 2, ncol = 1,labeller=as_labeller(c(`13`="\"Suggestion provided by the Help button seem incomplete.\"",`14`="\"Suggestions tell me how to use the AlienNutriSolve.\"")))+
  labs(title="Item 13 and 14 Experimental",x="", y = "% of users per group")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Dcol,Ucol), labels = c("DiCE","UFCE"))+
  scale_x_discrete(breaks=1:6, labels=c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree","Prefer not\nto answer"))+
  theme(plot.title = element_text(hjust = 0.5),axis.text.x = element_text(angle = 60,hjust = 0.95))

# safe summary to generate likert plots:
likert_items=df_survey_items_summary

# put all plots together
items_figure1_UserResponses <- ggarrange(items_p_FreqUserResponses,items_p_PercUserResponses,
                    ncol = 1, nrow = 2, heights=c(4,4), common.legend = TRUE)

# save
ggsave("Figures/item_13_and_14_UserResponses_EXP.pdf",width = 5, height = 6,)

# show
print("Display figures showing user responses in relevant survey items:")
items_figure1_UserResponses

```
On to the statistical comparison: for Likert-scale, we want a non-parametric statistical test for ordinal data, that's the WilcoxonMannWhitney U test.

```{r echo=FALSE, fig.height = 3, fig.width = 5, fig.align = "center"}

# extract response numbers per participant
df_survey_subjHelpfulness_responses = df_survey_items[df_survey_items$itemNo==13,]
df_survey_subjHelpfulness_responses = df_survey_subjHelpfulness_responses[!df_survey_subjHelpfulness_responses$checked==0,]
# take out "prefer not to answer" replies
df_survey_subjHelpfulness_responses = df_survey_subjHelpfulness_responses[!df_survey_subjHelpfulness_responses$responseNo==6,]

df_survey_subjUsability_responses = df_survey_items[df_survey_items$itemNo==14,]
df_survey_subjUsability_responses = df_survey_subjUsability_responses[!df_survey_subjUsability_responses$checked==0,]
# take out "prefer not to answer" replies
df_survey_subjUsability_responses = df_survey_subjUsability_responses[!df_survey_subjUsability_responses$responseNo==6,]

# treat as numeric to compute stats
df_survey_subjHelpfulness_responses$responseNo=as.numeric(df_survey_subjHelpfulness_responses$responseNo)
df_survey_subjUsability_responses$responseNo=as.numeric(df_survey_subjUsability_responses$responseNo)

# compute summary stats (mean, sd, sem)
df_survey_subjHelpfulness_summary=data_summary(df_survey_subjHelpfulness_responses, varname="responseNo", 
                    groupnames=c("group"))

df_survey_subjUsability_summary=data_summary(df_survey_subjUsability_responses, varname="responseNo", 
                    groupnames=c("group"))

# for plotting:
df_survey_subjHelpUsability_responses = df_survey_items[!df_survey_items$checked==0,]
df_survey_subjHelpUsability_responses = df_survey_subjHelpUsability_responses[!df_survey_subjHelpUsability_responses$responseNo==6,]
df_survey_subjHelpUsability_responses$responseNo=as.numeric(df_survey_subjHelpUsability_responses$responseNo)

# plot distribution
H2.1_figure2_UserResponses_violin = ggplot(df_survey_subjHelpUsability_responses, aes(x=group, y=responseNo, color=group, fill=group)) + 
  geom_violin(scale = "count")+
  geom_boxplot(width=0.1)+
  # geom_jitter(height = 0, width = 0.1)+ # ADD THIS TO DISPLAY INDIVIDUAL DATA POINTS!
  facet_wrap(vars(itemNo),nrow = 2, ncol = 1,labeller=as_labeller(c(`13`="\"Suggestion provided by the Help button seem incomplete.\"",`14`="\"Suggestions tell me how to use the AlienNutriSolve.\""))) +
  stat_summary(fun=mean, geom="point", shape=23, size=2, color="red")  +
  labs(title="Mean response for item 13 and 14",x="Group", y = "Response")+
  scale_y_continuous(limits = c(1, 5),breaks=1:5, labels=c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree"))+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=alpha(c(Dcol,Ucol),0.2), labels = c("DiCE","UFCE"))+
  scale_color_manual("Group", values=c(Dcol,Ucol), labels = c("DiCE","UFCE"))+
  theme(plot.title = element_text(hjust = 0.5))

# save
ggsave("Figures/H2.1_item_13_and_14_UserResponses_violin.pdf",width = 6, height = 4,)
H2.1_figure2_UserResponses_violin

# Stacked bar plot, the more appropriate visualization for likert data:
# separate "high" and "low" values
lows=likert_items[as.numeric(likert_items$responseNo)<4,]
highs=likert_items[as.numeric(likert_items$responseNo)>2,]
# NOTE: we take response no 6 out here, after percentages were computed
# THUS, THE RESPONSES WILL NOT SUM UP TO 100% ID PEOPLE CHOSE NOT TO ANSWER!
highs=highs[!highs$responseNo==6,]
  
# divide neutral category by 2 for plotting:
lows$PercUsersChecked[lows$responseNo==3]=lows$PercUsersChecked[lows$responseNo==3]/2
highs$PercUsersChecked[highs$responseNo==3]=highs$PercUsersChecked[highs$responseNo==3]/2

H2.1_figure2_UserResponses_stackedBar = ggplot() + scale_x_discrete(labels=c("U"="UFCE", "D"="DiCE")) +
  # annotation:
  annotate("rect", xmin = 1.6, xmax = 2.4, ymin = -100, ymax = 100, alpha=0.2, fill = Ucol)+
  # annotate("rect", xmin = 0.6, xmax = 1.4, ymin = -100, ymax = 100, alpha=0.2, fill = Ccol)+
  annotate("rect", xmin = 0.6, xmax = 1.4, ymin = -100, ymax = 100, alpha=0.2, fill = Dcol)+
  # geom_bar, add data high:
  geom_bar(data=highs[order(highs$responseNo, decreasing = F),], aes(x = group, y=PercUsersChecked, fill=responseNo, group=group), position="stack", stat="identity",width = 0.5) +
  # add border for high values:
  stat_summary(data=highs[order(highs$responseNo, decreasing = F),], aes(x = group, y = PercUsersChecked),
               fun = sum,geom = "col",colour = "black",fill=NA,width = 0.5,size=0.1)+
  # geom_bar, add data low:
  geom_bar(data=lows[order(lows$responseNo, decreasing = T),], aes(x = group, y=-PercUsersChecked, fill=responseNo, group=group), position="stack", stat="identity",width = 0.5) +
  # add border for high values:
  stat_summary(data=lows[order(lows$responseNo, decreasing = T),], aes(x = group, y=-PercUsersChecked),
               fun = sum,geom = "col",colour = "black",fill=NA,width = 0.5,size=0.1)+
  # flip coordinates:
  coord_flip(xlim=c(0.99,2.3)) +
  # more aesthetics:
  geom_hline(yintercept = 0, color =c("black"),size=0.1) +
  facet_wrap(vars(itemNo),nrow = 3, ncol = 1,labeller=as_labeller(c(`13`="\"Suggestion provided by the Help button seem incomplete.\"",`14`="\"Suggestions tell me how to use the AlienNutriSolve.\"")))+
  theme_bw(base_size = 10)+
theme(legend.position = "bottom",legend.title=element_blank(),legend.background = element_rect(fill="gray90", size=.5, linetype="dotted"),plot.title = element_text(hjust = 0.5))+
  labs(x="Group", y ="% of users")+
  scale_fill_manual("User response", values = likert_Okabe_Ito_palette,labels = c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree"))+
  scale_color_manual("Group", values=c(Dcol,Ucol), labels = c("DiCE","UFCE"))+
  scale_y_continuous(labels=c(100,50,0,50,100))

# save
ggsave("Figures/H2.1_13_and_14_UserResponses_stackedBar_EXP.pdf",width = 6, height = 4,)
H2.1_figure2_UserResponses_stackedBar
# show plots
# print("Mean user response for subjective helpfulness / usability:")
# H2.1_figure2_UserResponses_violin
# H2.1_figure2_UserResponses_stackedBar

# run stats, helpfulness judgements:
item13t="Wilcox"
item13test=uk_wilcox.test(df_survey_subjHelpfulness_responses$responseNo[df_survey_subjHelpfulness_responses$group=="U"],df_survey_subjHelpfulness_responses$responseNo[df_survey_subjHelpfulness_responses$group=="D"],paired=FALSE,exact=FALSE)
item13effsize=item13test$z_val/(sqrt(nrow(df_survey_subjHelpfulness_responses)))

matchingRes=paste(matchingRes,paste("\n","H2.1_item_13_14_Userresponses",sep=""),"NA",item13t,item13test$p.value,item13effsize,sep = ",")

# run stats, usability judgements:
item14t="Wilcox"
item14test=uk_wilcox.test(df_survey_subjUsability_responses$responseNo[df_survey_subjUsability_responses$group=="U"],df_survey_subjUsability_responses$responseNo[df_survey_subjUsability_responses$group=="D"],paired=FALSE,exact=FALSE)
item14effsize=item14test$z_val/(sqrt(nrow(df_survey_subjUsability_responses)))

matchingRes=paste(matchingRes,paste("\n","H2.1_item_13_14_UserResponses",sep=""),"NA",item14t,item14test$p.value,item14effsize,sep = ",")

# print(item13test$p.value)
# print(item14test$p.value)

```




```{r echo=FALSE, fig.height = 3, fig.width = 5, fig.align = "center"}
# add significance annotation to likert plots:

anno_df <- data.frame(label = c("n.s.(p=0.118)", "n.s.(p=0.177)"),itemNo   = c(13, 14))
H2.1_figure2_UserResponses_stackedBar_anno = H2.1_figure2_UserResponses_stackedBar + geom_text(
  data = anno_df, mapping = aes(x = Inf, y = -Inf, label = label), hjust = -0.1, vjust = 1.5, size=2, fontface = "italic")

# save
ggsave("Figures/final/item13_14_figure2_UserResponses_stackedBar_anno.pdf",width = 6, height = 5,)

# show plots
# print("Mean user response for item 13 and 14:")
H2.1_figure2_UserResponses_stackedBar_anno

```

The analysis revealed:

* Is there a significant difference in responses that suggestions seem incomplete? 

We compared responses of users in UFCE (M = `r df_survey_subjHelpfulness_summary$mean[df_survey_subjHelpfulness_summary$group=="U"]`, SEM = `r df_survey_subjHelpfulness_summary$sem[df_survey_subjHelpfulness_summary$group=="U"]`) and users in the DiCE (M = `r df_survey_subjHelpfulness_summary$mean[df_survey_subjHelpfulness_summary$group=="D"]`, SEM = `r df_survey_subjHelpfulness_summary$sem[df_survey_subjHelpfulness_summary$group=="D"]`) using a WilcoxonMannWhitney U test. This showed: U=`r item13test$statistic `, p=`r item13test$p.value `, r = `r item13effsize `

* Is there a significant in responses that suggestion tell how to use Alien Nutri-solver?: 
We compared responses of users in UFCE (M = `r df_survey_subjUsability_summary$mean[df_survey_subjUsability_summary$group=="U"]`, SEM = `r df_survey_subjUsability_summary$sem[df_survey_subjUsability_summary$group=="U"]`) and users in DiCE (M = `r df_survey_subjUsability_summary$mean[df_survey_subjUsability_summary$group=="D"]`, SEM = `r df_survey_subjUsability_summary$sem[df_survey_subjUsability_summary$group=="D"]`) using a WilcoxonMannWhitney U test. This showed: U=`r item14test$statistic `, p=`r item14test$p.value `, r = `r item14effsize`


### H3 Trust (survey items from 15 to 20)


#### Survey item 15 (control and experimental same)

```{r echo=FALSE, warning=FALSE, fig.height = 5.5, fig.width = 4.5}

# Descriptive stats
# subset to get only relevant data
df_survey_item15=df_survey[(df_survey$itemNo==15) & (!df_survey$group=='C') | (df_survey$itemNo==8) & (df_survey$group=='C'),]

# set itemNo and responseNo to factors, too
df_survey_item15$itemNo=as.factor(df_survey_item15$itemNo)
df_survey_item15$responseNo=as.factor(df_survey_item15$responseNo)

# summary(df_survey_item15)

# summarize to get overview values of frequencies and percentages
df_survey_item15_summary=dplyr::summarise(group_by(df_survey_item15, group, itemNo, responseNo),
          SumChecks=sum(checked),
          PercUsersChecked=100*(sum(checked)/length(unique(userId))))

# display frequency as raw counts
item15_p_FreqUserResponses = ggplot(data=df_survey_item15_summary, aes(x=responseNo,fill = group)) + 
  geom_bar(aes(y = SumChecks),stat="identity",position = position_dodge(preserve = "single"))+
  facet_wrap(vars(itemNo),nrow = 2, ncol = 1,labeller=as_labeller(c(`15`="\"I trust the predictions of the AlienNutriSolver.\"")))+
  labs(title="Trust item 8/15 control/exp",x="", y = "Frequency of answer")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Ccol, Ucol,Dcol), labels = c("Control", "DiCE", "UFCE"))+
  scale_x_discrete(breaks=1:6, labels=c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree","Prefer not\nto answer"))+
  theme(plot.title = element_text(hjust = 0.5),axis.text.x = element_text(angle = 60,hjust = 0.95))

# display frequency as percentage of all per group users (how many % of explanation users picked plant 1?)
item15_p_PercUserResponses = ggplot(data=df_survey_item15_summary, aes(x=responseNo,fill = group)) + 
  geom_bar(aes(y = PercUsersChecked),stat="identity",position = position_dodge(preserve = "single"))+
  facet_wrap(vars(itemNo),nrow = 2, ncol = 1,labeller=as_labeller(c(`15`="\"I trust the predictions of the AlienNutriSolver.\"")))+
  labs(title="trust item 8/15 control/exp",x="", y = "% of users per group")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Ccol,Dcol,Ucol), labels = c("Control", "DiCE", "UFCE"))+
  scale_x_discrete(breaks=1:6, labels=c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree","Prefer not\nto answer"))+
  theme(plot.title = element_text(hjust = 0.5),axis.text.x = element_text(angle = 60,hjust = 0.95))

# safe summary to generate likert plots:
likert_item15=df_survey_item15_summary

# put all plots together
item15_figure1_UserResponses <- ggarrange(item15_p_FreqUserResponses,item15_p_PercUserResponses,
                    ncol = 1, nrow = 2, heights=c(4,4), common.legend = TRUE)

# save
ggsave("Figures/item_15_trust_UserResponses_both.pdf",width = 5, height = 6,)

# show
# print("Display figures showing user responses in relevant survey items:")
item15_figure1_UserResponses

```
On to the statistical comparison: for Likert-scale, we want a non-parametric statistical test for ordinal data, that's the WilcoxonMannWhitney U test. UK: IN THE 2 GROUP CASE, IT SHOULD ACTUALLY BE KRUSKAL WALLIS AGAIN!!!

```{r echo=FALSE, fig.height = 3, fig.width = 5, fig.align = "center"}

# extract response numbers per participant
df_survey_subjHelpfulness_responses = df_survey_item15[(df_survey_item15$itemNo==15) & (!df_survey_item15$group=='C') ,]
df_survey_subjHelpfulness_responses = df_survey_subjHelpfulness_responses[!df_survey_subjHelpfulness_responses$checked==0,]
# take out "prefer not to answer" replies
df_survey_subjHelpfulness_responses = df_survey_subjHelpfulness_responses[!df_survey_subjHelpfulness_responses$responseNo==6,]

df_survey_subjUsability_responses = df_survey_item15[(df_survey_item15$itemNo==8) & (df_survey_item15$group=='C'),]
df_survey_subjUsability_responses = df_survey_subjUsability_responses[!df_survey_subjUsability_responses$checked==0,]
# take out "prefer not to answer" replies
df_survey_subjUsability_responses = df_survey_subjUsability_responses[!df_survey_subjUsability_responses$responseNo==6,]

# treat as numeric to compute stats
df_survey_subjHelpfulness_responses$responseNo=as.numeric(df_survey_subjHelpfulness_responses$responseNo)
df_survey_subjUsability_responses$responseNo=as.numeric(df_survey_subjUsability_responses$responseNo)

# df_survey_subjHelpfulness_responses
# compute summary stats (mean, sd, sem)
df_survey_subjHelpfulness_summary=data_summary(df_survey_subjHelpfulness_responses, varname="responseNo", 
                    groupnames=c("group"))

df_survey_subjUsability_summary=data_summary(df_survey_subjUsability_responses, varname="responseNo", 
                    groupnames=c("group"))

# for plotting:
df_survey_subjHelpUsability_responses = df_survey_item15[!df_survey_item15$checked==0,]
df_survey_subjHelpUsability_responses = df_survey_subjHelpUsability_responses[!df_survey_subjHelpUsability_responses$responseNo==6,]
df_survey_subjHelpUsability_responses$responseNo=as.numeric(df_survey_subjHelpUsability_responses$responseNo)

# plot distribution
item15_figure2_UserResponses_violin = ggplot(df_survey_subjHelpUsability_responses, aes(x=group, y=responseNo, color=group, fill=group)) + 
  geom_violin(scale = "count")+
  geom_boxplot(width=0.1)+
  #geom_jitter(height = 0, width = 0.1)+ # ADD THIS TO DISPLAY INDIVIDUAL DATA POINTS!
  facet_wrap(vars(itemNo),nrow = 2, ncol = 1,labeller=as_labeller(c(`15`="\"I trust the predictions of the AlienNutriSolver.\""))) +
  stat_summary(fun=mean, geom="point", shape=23, size=2, color="red")  +
  labs(titile="I trust the predictions of Alien Nutri-Solver",x="Group", y = "Response")+
  scale_y_continuous(limits = c(1, 5),breaks=1:5, labels=c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree"))+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=alpha(c(Ccol,Dcol,Ucol),0.2), labels = c("Control", "DiCE", "UFCE"))+
  scale_color_manual("Group", values=c(Ccol,Dcol,Ucol), labels = c("Control","UFCE", "DiCE"))+
  theme(plot.title = element_text(hjust = 0.5))
item15_figure2_UserResponses_violin
# save
ggsave("Figures/item15_8_UserResponses_violin.pdf",width = 6, height = 4,)

# Stacked bar plot, the more appropriate visualization for likert data:
# separate "high" and "low" values
lows=likert_item15[as.numeric(likert_item15$responseNo)<4,]
highs=likert_item15[as.numeric(likert_item15$responseNo)>2,]
# NOTE: we take response no 6 out here, after percentages were computed
# THUS, THE RESPONSES WILL NOT SUM UP TO 100% ID PEOPLE CHOSE NOT TO ANSWER!
highs=highs[!highs$responseNo==6,]
  
# divide neutral category by 2 for plotting:
lows$PercUsersChecked[lows$responseNo==3]=lows$PercUsersChecked[lows$responseNo==3]/2
highs$PercUsersChecked[highs$responseNo==3]=highs$PercUsersChecked[highs$responseNo==3]/2

item15_figure2_UserResponses_stackedBar = ggplot() + scale_x_discrete(labels=c("U"="UFCE","C"="Control", "D"="DiCE")) +
  # annotation:
  annotate("rect", xmin = 2.6, xmax = 3.4, ymin = -100, ymax = 100, alpha=0.2, fill = Ucol)+
  annotate("rect", xmin = 0.6, xmax = 1.4, ymin = -100, ymax = 100, alpha=0.2, fill = Ccol)+
  annotate("rect", xmin = 1.6, xmax = 2.4, ymin = -100, ymax = 100, alpha=0.2, fill = Dcol)+
  # geom_bar, add data high:
  geom_bar(data=highs[order(highs$responseNo, decreasing = F),], aes(x = group, y=PercUsersChecked, fill=responseNo, group=group), position="stack", stat="identity",width = 0.5) +
  # add border for high values:
  stat_summary(data=highs[order(highs$responseNo, decreasing = F),], aes(x = group, y = PercUsersChecked),
               fun = sum,geom = "col",colour = "black",fill=NA,width = 0.5,size=0.2)+
  # geom_bar, add data low:
  geom_bar(data=lows[order(lows$responseNo, decreasing = T),], aes(x = group, y=-PercUsersChecked, fill=responseNo, group=group), position="stack", stat="identity",width = 0.5) +
  # add border for high values:
  stat_summary(data=lows[order(lows$responseNo, decreasing = T),], aes(x = group, y=-PercUsersChecked),
               fun = sum,geom = "col",colour = "black",fill=NA,width = 0.5,size=0.2)+
  # flip coordinates:
  coord_flip(xlim=c(0.99,3.3)) +
  # more aesthetics:
  geom_hline(yintercept = 0, color =c("black"),size=0.1) +
  #facet_wrap(vars(itemNo),nrow = 3, ncol = 1,labeller=as_labeller(c(`15`="\"I trust the predictions of the AlienNutriSolver.\"")))+
  theme_bw(base_size = 10)+
theme(legend.position = "bottom",legend.title=element_blank(),legend.background = element_rect(fill="gray90", size=.5, linetype="dotted"),plot.title = element_text(hjust = 0.5))+
  labs(x="Group", y ="% of users")+
  scale_fill_manual("User response", values = likert_Okabe_Ito_palette,labels = c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree"))+
  scale_color_manual("Group", values=c(Ucol,Dcol,Ccol), labels = c("UFCE", "DiCE", "Control"))+
  scale_y_continuous(labels=c(100,50,0,50,100))

# save
ggsave("Figures/item15_8_UserResponses_stackedBar.pdf",width = 6, height = 4,)
item15_figure2_UserResponses_stackedBar

# show plots
# print("Mean user response for subjective helpfulness / usability:")
# H2.1_figure2_UserResponses_violin
# H2.1_figure2_UserResponses_stackedBar

#######
# UK: adapted analysis - Kruskal Wallis on all groups, followed by pairwise post-hoc tests
# # run stats, ufce-control:
# item15t_uc="Wilcox"
# item15test_uc=uk_wilcox.test(df_survey_subjHelpfulness_responses$responseNo[df_survey_subjHelpfulness_responses$group=="U"],df_survey_subjHelpUsability_responses$responseNo[df_survey_subjHelpUsability_responses$group=="C"],paired=FALSE,exact=FALSE)
# item15effsize_uc=item15test_uc$z_val/(sqrt(nrow(df_survey_subjHelpfulness_responses)))
# 
# matchingRes=paste(matchingRes,paste("\n","item 15 ufce-control",sep=""),"NA",item15t_uc,item15test_uc$p.value,item15effsize_uc,sep = ",")
# 
# # run stats, dice-control:
# item15t_dc="Wilcox"
# item15test_dc=uk_wilcox.test(df_survey_subjHelpfulness_responses$responseNo[df_survey_subjHelpfulness_responses$group=="D"],df_survey_subjHelpUsability_responses$responseNo[df_survey_subjHelpUsability_responses$group=="C"],paired=FALSE,exact=FALSE)
# item15effsize_dc=item15test_dc$z_val/(sqrt(nrow(df_survey_subjHelpfulness_responses)))
# 
# matchingRes=paste(matchingRes,paste("\n","item 15 dice-control ",sep=""),"NA",item15t_dc,item15test_dc$p.value,item15effsize_dc,sep = ",")
# 
# # run stats, ufce-dice:
# item15t_ud="Wilcox"
# item15test_ud=uk_wilcox.test(df_survey_subjHelpfulness_responses$responseNo[df_survey_subjHelpfulness_responses$group=="U"],df_survey_subjHelpfulness_responses$responseNo[df_survey_subjHelpfulness_responses$group=="D"],paired=FALSE,exact=FALSE)
# item15effsize_ud=item15test_ud$z_val/(sqrt(nrow(df_survey_subjHelpfulness_responses)))
# 
# item15test_dc=uk_wilcox.test(df_survey_subjHelpfulness_responses$responseNo[df_survey_subjHelpfulness_responses$group=="D"],df_survey_subjHelpUsability_responses$responseNo[df_survey_subjHelpUsability_responses$group=="C"],paired=FALSE,exact=FALSE)
# # item15effsize_dc=item15test_dc$z_val/(sqrt(nrow(df_survey_subjHelpfulness_responses)))

item15t="KruskalWallis"
item15test=kruskal.test(responseNo~group,data=df_survey_subjHelpfulness_responses)
#item15test_effsize=kruskal_effsize(responseNo~group,data=df_survey_subjHelpfulness_responses)

## NOT SIGNIFICANT, so no posthoc tests!

print(item15test$p.value)
#print(item15test_uc$p.value)
#print(item15test_dc$p.value)
#print(item15test_ud$p.value)
```


```{r echo=FALSE, fig.height = 3, fig.width = 5, fig.align = "center"}
# add significance annotation to likert plots:

anno_df <- data.frame(label = c("n.s.(p=0.951)"),itemNo   = c(8,15))
item15_figure2_UserResponses_stackedBar_anno = item15_figure2_UserResponses_stackedBar + geom_text(
  data = anno_df, mapping = aes(x = Inf, y = -Inf, label = label), hjust = -0.1, vjust = 1.5, size=2, fontface = "italic")

# save
ggsave("Figures/final/item_15_figure2_UserResponses_stackedBar_anno.pdf",width = 6, height = 5,)

# show plots
print("Mean user response for item 15:")
item15_figure2_UserResponses_stackedBar_anno

```

The analysis revealed:

* Is there a significant difference in responses for 'I trust the predictions of the Alien Nutri-Solver?

We looked at this question using a `r item15t` test. This showed: chi-squred(x^2)=`r item15test$statistic `, p=`r item15test$p.value `, df = `r item15test$parameter `.

#### survey item 16 and 17

#### Explanation groups

```{r echo=FALSE, warning=FALSE, fig.height = 5.5, fig.width = 4.5}

# Descriptive stats
# subset to get only relevant data
df_survey_items=df_survey[(df_survey$itemNo==16 | df_survey$itemNo==17) & (!df_survey$group=='C'),]

# set itemNo and responseNo to factors, too
df_survey_items$itemNo=as.factor(df_survey_items$itemNo)
df_survey_items$responseNo=as.factor(df_survey_items$responseNo)

# summary(df_survey_items)

# summarize to get overview values of frequencies and percentages
df_survey_items_summary=dplyr::summarise(group_by(df_survey_items, group, itemNo, responseNo),
          SumChecks=sum(checked),
          PercUsersChecked=100*(sum(checked)/length(unique(userId))))

# display frequency as raw counts
items_p_FreqUserResponses = ggplot(data=df_survey_items_summary, aes(x=responseNo,fill = group)) + 
  geom_bar(aes(y = SumChecks),stat="identity",position = position_dodge(preserve = "single"))+
  facet_wrap(vars(itemNo),nrow = 2, ncol = 1,labeller=as_labeller(c(`16`="\"I do not trust the suggestions.\"",`17`="\"I am confident in the suggestions.\"")))+
  labs(title="Item 16 and 17 Experimental",x="", y = "Frequency of answer")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Dcol,Ucol), labels = c("DiCE","UFCE"))+
  scale_x_discrete(breaks=1:6, labels=c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree","Prefer not\nto answer"))+
  theme(plot.title = element_text(hjust = 0.5),axis.text.x = element_text(angle = 60,hjust = 0.95))

# display frequency as percentage of all per group users (how many % of explanation users picked plant 1?)
items_p_PercUserResponses = ggplot(data=df_survey_items_summary, aes(x=responseNo,fill = group)) + 
  geom_bar(aes(y = PercUsersChecked),stat="identity",position = position_dodge(preserve = "single"))+
  facet_wrap(vars(itemNo),nrow = 2, ncol = 1,labeller=as_labeller(c(`16`="\"I do not trust the suggestions.\"",`17`="\"I am confident in the suggestions.\"")))+
  labs(title="Item 16 and 17 Experimental",x="", y = "% of users per group")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Dcol,Ucol), labels = c("DiCE","UFCE"))+
  scale_x_discrete(breaks=1:6, labels=c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree","Prefer not\nto answer"))+
  theme(plot.title = element_text(hjust = 0.5),axis.text.x = element_text(angle = 60,hjust = 0.95))

# safe summary to generate likert plots:
likert_items=df_survey_items_summary

# put all plots together
items_figure1_UserResponses <- ggarrange(items_p_FreqUserResponses,items_p_PercUserResponses,
                    ncol = 1, nrow = 2, heights=c(4,4), common.legend = TRUE)

# save
ggsave("Figures/item_16_and_17_UserResponses_EXP.pdf",width = 5, height = 6,)

# show
# print("Display figures showing user responses in relevant survey items:")
items_figure1_UserResponses

```
On to the statistical comparison: for Likert-scale, we want a non-parametric statistical test for ordinal data, that's the WilcoxonMannWhitney U test.

```{r echo=FALSE, fig.height = 3, fig.width = 5, fig.align = "center"}

# extract response numbers per participant
df_survey_subjHelpfulness_responses = df_survey_items[df_survey_items$itemNo==16,]
df_survey_subjHelpfulness_responses = df_survey_subjHelpfulness_responses[!df_survey_subjHelpfulness_responses$checked==0,]
# take out "prefer not to answer" replies
df_survey_subjHelpfulness_responses = df_survey_subjHelpfulness_responses[!df_survey_subjHelpfulness_responses$responseNo==6,]

df_survey_subjUsability_responses = df_survey_items[df_survey_items$itemNo==17,]
df_survey_subjUsability_responses = df_survey_subjUsability_responses[!df_survey_subjUsability_responses$checked==0,]
# take out "prefer not to answer" replies
df_survey_subjUsability_responses = df_survey_subjUsability_responses[!df_survey_subjUsability_responses$responseNo==6,]

# treat as numeric to compute stats
df_survey_subjHelpfulness_responses$responseNo=as.numeric(df_survey_subjHelpfulness_responses$responseNo)
df_survey_subjUsability_responses$responseNo=as.numeric(df_survey_subjUsability_responses$responseNo)

# compute summary stats (mean, sd, sem)
df_survey_subjHelpfulness_summary=data_summary(df_survey_subjHelpfulness_responses, varname="responseNo", 
                    groupnames=c("group"))

df_survey_subjUsability_summary=data_summary(df_survey_subjUsability_responses, varname="responseNo", 
                    groupnames=c("group"))

# for plotting:
df_survey_subjHelpUsability_responses = df_survey_items[!df_survey_items$checked==0,]
df_survey_subjHelpUsability_responses = df_survey_subjHelpUsability_responses[!df_survey_subjHelpUsability_responses$responseNo==6,]
df_survey_subjHelpUsability_responses$responseNo=as.numeric(df_survey_subjHelpUsability_responses$responseNo)

# plot distribution
item16_17_figure2_UserResponses_violin = ggplot(df_survey_subjHelpUsability_responses, aes(x=group, y=responseNo, color=group, fill=group)) + 
  geom_violin(scale = "count")+
  geom_boxplot(width=0.1)+
  # geom_jitter(height = 0, width = 0.1)+ # ADD THIS TO DISPLAY INDIVIDUAL DATA POINTS!
  facet_wrap(vars(itemNo),nrow = 2, ncol = 1,labeller=as_labeller(c(`16`="\"I do not trust the suggestions.\"",`17`="\"I am confident in the suggestions.\""))) +
  stat_summary(fun=mean, geom="point", shape=23, size=2, color="red")  +
  labs(title="Mean response for item 16 and 17",x="Group", y = "Response")+
  scale_y_continuous(limits = c(1, 5),breaks=1:5, labels=c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree"))+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=alpha(c(Dcol,Ucol),0.2), labels = c("DiCE","UFCE"))+
  scale_color_manual("Group", values=c(Dcol,Ucol), labels = c("DiCE","UFCE"))+
  theme(plot.title = element_text(hjust = 0.5))

# save
ggsave("Figures/item_16_and_17_UserResponses_violin.pdf",width = 6, height = 4,)
item16_17_figure2_UserResponses_violin

# Stacked bar plot, the more appropriate visualization for likert data:
# separate "high" and "low" values
lows=likert_items[as.numeric(likert_items$responseNo)<4,]
highs=likert_items[as.numeric(likert_items$responseNo)>2,]
# NOTE: we take response no 6 out here, after percentages were computed
# THUS, THE RESPONSES WILL NOT SUM UP TO 100% ID PEOPLE CHOSE NOT TO ANSWER!
highs=highs[!highs$responseNo==6,]
  
# divide neutral category by 2 for plotting:
lows$PercUsersChecked[lows$responseNo==3]=lows$PercUsersChecked[lows$responseNo==3]/2
highs$PercUsersChecked[highs$responseNo==3]=highs$PercUsersChecked[highs$responseNo==3]/2

item16_17_figure2_UserResponses_stackedBar = ggplot() + scale_x_discrete(labels=c("U"="UFCE", "D"="DiCE")) +
  # annotation:
  annotate("rect", xmin = 1.6, xmax = 2.4, ymin = -100, ymax = 100, alpha=0.2, fill = Ucol)+
  # annotate("rect", xmin = 0.6, xmax = 1.4, ymin = -100, ymax = 100, alpha=0.2, fill = Ccol)+
  annotate("rect", xmin = 0.6, xmax = 1.4, ymin = -100, ymax = 100, alpha=0.2, fill = Dcol)+
  # geom_bar, add data high:
  geom_bar(data=highs[order(highs$responseNo, decreasing = F),], aes(x = group, y=PercUsersChecked, fill=responseNo, group=group), position="stack", stat="identity",width = 0.5) +
  # add border for high values:
  stat_summary(data=highs[order(highs$responseNo, decreasing = F),], aes(x = group, y = PercUsersChecked),
               fun = sum,geom = "col",colour = "black",fill=NA,width = 0.5,size=0.1)+
  # geom_bar, add data low:
  geom_bar(data=lows[order(lows$responseNo, decreasing = T),], aes(x = group, y=-PercUsersChecked, fill=responseNo, group=group), position="stack", stat="identity",width = 0.5) +
  # add border for high values:
  stat_summary(data=lows[order(lows$responseNo, decreasing = T),], aes(x = group, y=-PercUsersChecked),
               fun = sum,geom = "col",colour = "black",fill=NA,width = 0.5,size=0.1)+
  # flip coordinates:
  coord_flip(xlim=c(0.99,2.3)) +
  # more aesthetics:
  geom_hline(yintercept = 0, color =c("black"),size=0.1) +
  facet_wrap(vars(itemNo),nrow = 3, ncol = 1,labeller=as_labeller(c(`16`="\"I do not trust the suggestions.\"",`17`="\"I am confident in the suggestions.\"")))+
  theme_bw(base_size = 10)+
theme(legend.position = "bottom",legend.title=element_blank(),legend.background = element_rect(fill="gray90", size=.5, linetype="dotted"),plot.title = element_text(hjust = 0.5))+
  labs(x="Group", y ="% of users")+
  scale_fill_manual("User response", values = likert_Okabe_Ito_palette,labels = c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree"))+
  scale_color_manual("Group", values=c(Dcol,Ucol), labels = c("DiCE","UFCE"))+
  scale_y_continuous(labels=c(100,50,0,50,100))

# save
ggsave("Figures/item_16_and_17_UserResponses_stackedBar_EXP.pdf",width = 6, height = 4,)
item16_17_figure2_UserResponses_stackedBar
# show plots
# print("Mean user response for subjective helpfulness / usability:")
# H2.1_figure2_UserResponses_violin
# H2.1_figure2_UserResponses_stackedBar

# run stats, helpfulness judgements:
item16t="Wilcox"
item16test=uk_wilcox.test(df_survey_subjHelpfulness_responses$responseNo[df_survey_subjHelpfulness_responses$group=="U"],df_survey_subjHelpfulness_responses$responseNo[df_survey_subjHelpfulness_responses$group=="D"],paired=FALSE,exact=FALSE)
item16effsize=item16test$z_val/(sqrt(nrow(df_survey_subjHelpfulness_responses)))

matchingRes=paste(matchingRes,paste("\n","item_16_17_Userresponses",sep=""),"NA",item16t,item16test$p.value,item16effsize,sep = ",")

# run stats, usability judgements:
item17t="Wilcox"
item17test=uk_wilcox.test(df_survey_subjUsability_responses$responseNo[df_survey_subjUsability_responses$group=="U"],df_survey_subjUsability_responses$responseNo[df_survey_subjUsability_responses$group=="D"],paired=FALSE,exact=FALSE)
item17effsize=item17test$z_val/(sqrt(nrow(df_survey_subjUsability_responses)))

matchingRes=paste(matchingRes,paste("\n","item_16_17_UserResponses",sep=""),"NA",item17t,item17test$p.value,item17effsize,sep = ",")

print(item16test$p.value)
print(item17test$p.value)

```



```{r echo=FALSE, fig.height = 3, fig.width = 5, fig.align = "center"}
# add significance annotation to likert plots:

anno_df <- data.frame(label = c("n.s.(p=0.796)", "*p=<0.05"),itemNo   = c(16, 17))
item16_17_figure2_UserResponses_stackedBar_anno = item16_17_figure2_UserResponses_stackedBar + geom_text(
  data = anno_df, mapping = aes(x = Inf, y = -Inf, label = label), hjust = -0.1, vjust = 1.5, size=2, fontface = "italic")

# save
ggsave("Figures/final/item16_17_figure2_UserResponses_stackedBar_anno.pdf",width = 6, height = 5,)

# show plots
print("Mean user response for item 16 and 17:")
item16_17_figure2_UserResponses_stackedBar_anno

```
The analysis revealed:

* Is there a significant difference in responses to trust the suggestions? 

We compared responses of users in UFCE (M = `r df_survey_subjHelpfulness_summary$mean[df_survey_subjHelpfulness_summary$group=="U"]`, SEM = `r df_survey_subjHelpfulness_summary$sem[df_survey_subjHelpfulness_summary$group=="U"]`) and users in the DiCE (M = `r df_survey_subjHelpfulness_summary$mean[df_survey_subjHelpfulness_summary$group=="D"]`, SEM = `r df_survey_subjHelpfulness_summary$sem[df_survey_subjHelpfulness_summary$group=="D"]`) using a WilcoxonMannWhitney U test. This showed: U=`r item16test$statistic `, p=`r item16test$p.value `, r = `r item16effsize `

* Is there a significant difference in responses that users are confident in the suggestions?: 
We compared responses of users in UFCE (M = `r df_survey_subjUsability_summary$mean[df_survey_subjUsability_summary$group=="U"]`, SEM = `r df_survey_subjUsability_summary$sem[df_survey_subjUsability_summary$group=="U"]`) and users in DiCE (M = `r df_survey_subjUsability_summary$mean[df_survey_subjUsability_summary$group=="D"]`, SEM = `r df_survey_subjUsability_summary$sem[df_survey_subjUsability_summary$group=="D"]`) using a WilcoxonMannWhitney U test. This showed: U=`r item17test$statistic `, p=`r item17test$p.value `, r = `r item17effsize`

#### survey item 18 and 19

#### Explanation groups

```{r echo=FALSE, warning=FALSE, fig.height = 5.5, fig.width = 4.5}

# Descriptive stats
# subset to get only relevant data
df_survey_items=df_survey[(df_survey$itemNo==18 | df_survey$itemNo==19) & (!df_survey$group=='C'),]

# set itemNo and responseNo to factors, too
df_survey_items$itemNo=as.factor(df_survey_items$itemNo)
df_survey_items$responseNo=as.factor(df_survey_items$responseNo)

# summary(df_survey_items)

# summarize to get overview values of frequencies and percentages
df_survey_items_summary=dplyr::summarise(group_by(df_survey_items, group, itemNo, responseNo),
          SumChecks=sum(checked),
          PercUsersChecked=100*(sum(checked)/length(unique(userId))))

# display frequency as raw counts
items_p_FreqUserResponses = ggplot(data=df_survey_items_summary, aes(x=responseNo,fill = group)) + 
  geom_bar(aes(y = SumChecks),stat="identity",position = position_dodge(preserve = "single"))+
  facet_wrap(vars(itemNo),nrow = 2, ncol = 1,labeller=as_labeller(c(`18`="\"I do not feel safe when I rely on the suggestions.\"",`19`="\"I am wary of the suggestions.\"")))+
  labs(title="Item 18 and 19 Experimental",x="", y = "Frequency of answer")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Dcol,Ucol), labels = c("DiCE","UFCE"))+
  scale_x_discrete(breaks=1:6, labels=c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree","Prefer not\nto answer"))+
  theme(plot.title = element_text(hjust = 0.5),axis.text.x = element_text(angle = 60,hjust = 0.95))

# display frequency as percentage of all per group users (how many % of explanation users picked plant 1?)
items_p_PercUserResponses = ggplot(data=df_survey_items_summary, aes(x=responseNo,fill = group)) + 
  geom_bar(aes(y = PercUsersChecked),stat="identity",position = position_dodge(preserve = "single"))+
  facet_wrap(vars(itemNo),nrow = 2, ncol = 1,labeller=as_labeller(c(`18`="\"I do not feel safe when I rely on the suggestions.\"",`19`="\"I am wary of the suggestions.\"")))+
  labs(title="Item 18 and 19 Experimental",x="", y = "% of users per group")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Dcol,Ucol), labels = c("DiCE","UFCE"))+
  scale_x_discrete(breaks=1:6, labels=c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree","Prefer not\nto answer"))+
  theme(plot.title = element_text(hjust = 0.5),axis.text.x = element_text(angle = 60,hjust = 0.95))

# safe summary to generate likert plots:
likert_items=df_survey_items_summary

# put all plots together
items_figure1_UserResponses <- ggarrange(items_p_FreqUserResponses,items_p_PercUserResponses,
                    ncol = 1, nrow = 2, heights=c(4,4), common.legend = TRUE)

# save
ggsave("Figures/item_18_and_19_UserResponses_EXP.pdf",width = 5, height = 6,)

# show
# print("Display figures showing user responses in relevant survey items:")
items_figure1_UserResponses

```
On to the statistical comparison: for Likert-scale, we want a non-parametric statistical test for ordinal data, that's the WilcoxonMannWhitney U test.

```{r echo=FALSE, fig.height = 3, fig.width = 5, fig.align = "center"}

# extract response numbers per participant
df_survey_subjHelpfulness_responses = df_survey_items[df_survey_items$itemNo==18,]
df_survey_subjHelpfulness_responses = df_survey_subjHelpfulness_responses[!df_survey_subjHelpfulness_responses$checked==0,]
# take out "prefer not to answer" replies
df_survey_subjHelpfulness_responses = df_survey_subjHelpfulness_responses[!df_survey_subjHelpfulness_responses$responseNo==6,]

df_survey_subjUsability_responses = df_survey_items[df_survey_items$itemNo==19,]
df_survey_subjUsability_responses = df_survey_subjUsability_responses[!df_survey_subjUsability_responses$checked==0,]
# take out "prefer not to answer" replies
df_survey_subjUsability_responses = df_survey_subjUsability_responses[!df_survey_subjUsability_responses$responseNo==6,]

# treat as numeric to compute stats
df_survey_subjHelpfulness_responses$responseNo=as.numeric(df_survey_subjHelpfulness_responses$responseNo)
df_survey_subjUsability_responses$responseNo=as.numeric(df_survey_subjUsability_responses$responseNo)

# compute summary stats (mean, sd, sem)
df_survey_subjHelpfulness_summary=data_summary(df_survey_subjHelpfulness_responses, varname="responseNo", 
                    groupnames=c("group"))

df_survey_subjUsability_summary=data_summary(df_survey_subjUsability_responses, varname="responseNo", 
                    groupnames=c("group"))

# for plotting:
df_survey_subjHelpUsability_responses = df_survey_items[!df_survey_items$checked==0,]
df_survey_subjHelpUsability_responses = df_survey_subjHelpUsability_responses[!df_survey_subjHelpUsability_responses$responseNo==6,]
df_survey_subjHelpUsability_responses$responseNo=as.numeric(df_survey_subjHelpUsability_responses$responseNo)

# plot distribution
item18_19_figure2_UserResponses_violin = ggplot(df_survey_subjHelpUsability_responses, aes(x=group, y=responseNo, color=group, fill=group)) + 
  geom_violin(scale = "count")+
  geom_boxplot(width=0.1)+
  # geom_jitter(height = 0, width = 0.1)+ # ADD THIS TO DISPLAY INDIVIDUAL DATA POINTS!
  facet_wrap(vars(itemNo),nrow = 2, ncol = 1,labeller=as_labeller(c(`18`="\"I do not feel safe when I rely on the suggestions.\"",`17`="\"I am wary of the suggestions.\""))) +
  stat_summary(fun=mean, geom="point", shape=23, size=2, color="red")  +
  labs(title="Mean response for item 18 and 19",x="Group", y = "Response")+
  scale_y_continuous(limits = c(1, 5),breaks=1:5, labels=c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree"))+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=alpha(c(Dcol,Ucol),0.2), labels = c("DiCE","UFCE"))+
  scale_color_manual("Group", values=c(Dcol,Ucol), labels = c("DiCE","UFCE"))+
  theme(plot.title = element_text(hjust = 0.5))

# save
ggsave("Figures/item_18_and_19_UserResponses_violin.pdf",width = 6, height = 4,)
item18_19_figure2_UserResponses_violin

# Stacked bar plot, the more appropriate visualization for likert data:
# separate "high" and "low" values
lows=likert_items[as.numeric(likert_items$responseNo)<4,]
highs=likert_items[as.numeric(likert_items$responseNo)>2,]
# NOTE: we take response no 6 out here, after percentages were computed
# THUS, THE RESPONSES WILL NOT SUM UP TO 100% ID PEOPLE CHOSE NOT TO ANSWER!
highs=highs[!highs$responseNo==6,]
  
# divide neutral category by 2 for plotting:
lows$PercUsersChecked[lows$responseNo==3]=lows$PercUsersChecked[lows$responseNo==3]/2
highs$PercUsersChecked[highs$responseNo==3]=highs$PercUsersChecked[highs$responseNo==3]/2

item18_19_figure2_UserResponses_stackedBar = ggplot() + scale_x_discrete(labels=c("U"="UFCE", "D"="DiCE")) +
  # annotation:
  annotate("rect", xmin = 1.6, xmax = 2.4, ymin = -100, ymax = 100, alpha=0.2, fill = Ucol)+
  # annotate("rect", xmin = 0.6, xmax = 1.4, ymin = -100, ymax = 100, alpha=0.2, fill = Ccol)+
  annotate("rect", xmin = 0.6, xmax = 1.4, ymin = -100, ymax = 100, alpha=0.2, fill = Dcol)+
  # geom_bar, add data high:
  geom_bar(data=highs[order(highs$responseNo, decreasing = F),], aes(x = group, y=PercUsersChecked, fill=responseNo, group=group), position="stack", stat="identity",width = 0.5) +
  # add border for high values:
  stat_summary(data=highs[order(highs$responseNo, decreasing = F),], aes(x = group, y = PercUsersChecked),
               fun = sum,geom = "col",colour = "black",fill=NA,width = 0.5,size=0.1)+
  # geom_bar, add data low:
  geom_bar(data=lows[order(lows$responseNo, decreasing = T),], aes(x = group, y=-PercUsersChecked, fill=responseNo, group=group), position="stack", stat="identity",width = 0.5) +
  # add border for high values:
  stat_summary(data=lows[order(lows$responseNo, decreasing = T),], aes(x = group, y=-PercUsersChecked),
               fun = sum,geom = "col",colour = "black",fill=NA,width = 0.5,size=0.1)+
  # flip coordinates:
  coord_flip(xlim=c(0.99,2.3)) +
  # more aesthetics:
  geom_hline(yintercept = 0, color =c("black"),size=0.1) +
  facet_wrap(vars(itemNo),nrow = 3, ncol = 1,labeller=as_labeller(c(`18`="\"I do not feel safe when I rely on the suggestions.\"",`19`="\"I am wary of the suggestions.\"")))+
  theme_bw(base_size = 10)+
theme(legend.position = "bottom",legend.title=element_blank(),legend.background = element_rect(fill="gray90", size=.5, linetype="dotted"),plot.title = element_text(hjust = 0.5))+
  labs(x="Group", y ="% of users")+
  scale_fill_manual("User response", values = likert_Okabe_Ito_palette,labels = c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree"))+
  scale_color_manual("Group", values=c(Dcol,Ucol), labels = c("DiCE","UFCE"))+
  scale_y_continuous(labels=c(100,50,0,50,100))

# save
ggsave("Figures/18_and_19_UserResponses_stackedBar_EXP.pdf",width = 6, height = 4,)
item18_19_figure2_UserResponses_stackedBar
# show plots
# print("Mean user response for subjective helpfulness / usability:")
# H2.1_figure2_UserResponses_violin
# H2.1_figure2_UserResponses_stackedBar

# run stats, helpfulness judgements:
item18t="Wilcox"
item18test=uk_wilcox.test(df_survey_subjHelpfulness_responses$responseNo[df_survey_subjHelpfulness_responses$group=="U"],df_survey_subjHelpfulness_responses$responseNo[df_survey_subjHelpfulness_responses$group=="D"],paired=FALSE,exact=FALSE)
item18effsize=item18test$z_val/(sqrt(nrow(df_survey_subjHelpfulness_responses)))

matchingRes=paste(matchingRes,paste("\n","item_18_19_Userresponses",sep=""),"NA",item18t,item18test$p.value,item18effsize,sep = ",")

# run stats, usability judgements:
item19t="Wilcox"
item19test=uk_wilcox.test(df_survey_subjUsability_responses$responseNo[df_survey_subjUsability_responses$group=="U"],df_survey_subjUsability_responses$responseNo[df_survey_subjUsability_responses$group=="D"],paired=FALSE,exact=FALSE)
item19effsize=item19test$z_val/(sqrt(nrow(df_survey_subjUsability_responses)))

matchingRes=paste(matchingRes,paste("\n","item_18_19_UserResponses",sep=""),"NA",item19t,item19test$p.value,item19effsize,sep = ",")

print(item18test$p.value)
print(item19test$p.value)
```



```{r echo=FALSE, fig.height = 3, fig.width = 5, fig.align = "center"}
# add significance annotation to likert plots:

anno_df <- data.frame(label = c("**p<0.01", "n.s.(p=0.296)"),itemNo   = c(18, 19))
item18_19_figure2_UserResponses_stackedBar_anno = item18_19_figure2_UserResponses_stackedBar + geom_text(
  data = anno_df, mapping = aes(x = Inf, y = -Inf, label = label), hjust = -0.1, vjust = 1.5, size=2, fontface = "italic")

# save
ggsave("Figures/final/item18_19_figure2_UserResponses_stackedBar_anno.pdf",width = 6, height = 5,)

# show plots
# print("Mean user response for item 18 and 19:")
item18_19_figure2_UserResponses_stackedBar_anno

```

The analysis revealed:

* Is there a significant difference in responses to i do not feel safe when user rely on suggestions? 

We compared responses of users in UFCE (M = `r df_survey_subjHelpfulness_summary$mean[df_survey_subjHelpfulness_summary$group=="U"]`, SEM = `r df_survey_subjHelpfulness_summary$sem[df_survey_subjHelpfulness_summary$group=="U"]`) and users in the DiCE (M = `r df_survey_subjHelpfulness_summary$mean[df_survey_subjHelpfulness_summary$group=="D"]`, SEM = `r df_survey_subjHelpfulness_summary$sem[df_survey_subjHelpfulness_summary$group=="D"]`) using a WilcoxonMannWhitney U test. This showed: U=`r item18test$statistic `, p=`r item18test$p.value `, r = `r item18effsize `

* Is there a significant difference in responses that user is wary of suggestions?: 
We compared responses of users in UFCE (M = `r df_survey_subjUsability_summary$mean[df_survey_subjUsability_summary$group=="U"]`, SEM = `r df_survey_subjUsability_summary$sem[df_survey_subjUsability_summary$group=="U"]`) and users in DiCE (M = `r df_survey_subjUsability_summary$mean[df_survey_subjUsability_summary$group=="D"]`, SEM = `r df_survey_subjUsability_summary$sem[df_survey_subjUsability_summary$group=="D"]`) using a WilcoxonMannWhitney U test. This showed: U=`r item19test$statistic `, p=`r item19test$p.value `, r = `r item19effsize`


### survey item 20 Exp.Preference (Exp)

Item 20. I like using the suggestions on what choice would have led to a better result provided by the Help button how to select a good diet to increase the fitness of the Shub.  [PREFERENCE OF EXPLANATIONS, source: Vilone/Hoffman revised] 


```{r echo=FALSE, warning=FALSE, fig.height = 5.5, fig.width = 4.5}

# Descriptive stats
# subset to get only relevant data
df_survey_item5=df_survey[(df_survey$itemNo==20) & (!df_survey$group=='C'),]

# set itemNo and responseNo to factors, too
df_survey_item5$itemNo=as.factor(df_survey_item5$itemNo)
df_survey_item5$responseNo=as.factor(df_survey_item5$responseNo)

summary(df_survey_item5)

# summarize to get overview values of frequencies and percentages
df_survey_item5_summary=dplyr::summarise(group_by(df_survey_item5, group, itemNo, responseNo),
          SumChecks=sum(checked),
          PercUsersChecked=100*(sum(checked)/length(unique(userId))))

# display frequency as raw counts
item5_p_FreqUserResponses = ggplot(data=df_survey_item5_summary, aes(x=responseNo,fill = group)) + 
  geom_bar(aes(y = SumChecks),stat="identity",position = position_dodge(preserve = "single"))+
  facet_wrap(vars(itemNo),nrow = 1, ncol = 1,labeller=as_labeller(c(`5`="\"Preference of explanation.\"")))+
  labs(title="Item 20 preference",x="", y = "Frequency of answer")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Dcol,Ucol), labels = c("DiCE","UFCE"))+
  scale_x_discrete(breaks=1:6, labels=c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree","Prefer not\nto answer"))+
  theme(plot.title = element_text(hjust = 0.5),axis.text.x = element_text(angle = 60,hjust = 0.95))

# display frequency as percentage of all per group users (how many % of explanation users picked plant 1?)
item5_p_PercUserResponses = ggplot(data=df_survey_item5_summary, aes(x=responseNo,fill = group)) + 
  geom_bar(aes(y = PercUsersChecked),stat="identity",position = position_dodge(preserve = "single"))+
  facet_wrap(vars(itemNo),nrow = 1, ncol = 1,labeller=as_labeller(c(`5`="\"Actionability.\"")))+
  labs(title="Item 5 actionability",x="", y = "% of users per group")+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=c(Dcol,Ucol), labels = c("DiCE","UFCE"))+
  scale_x_discrete(breaks=1:6, labels=c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree","Prefer not\nto answer"))+
  theme(plot.title = element_text(hjust = 0.5),axis.text.x = element_text(angle = 60,hjust = 0.95))

# safe summary to generate likert plots:
likert_item5=df_survey_item5_summary

# put all plots together
item5_figure1_UserResponses <- ggarrange(item5_p_FreqUserResponses,item5_p_PercUserResponses,
                    ncol = 1, nrow = 1, heights=c(4,4), common.legend = TRUE)

# save
# ggsave("Figures/item_5_actionability_UserResponses.pdf",width = 5, height = 6,)

# show
# print("Display figures showing user responses in relevant survey items:")
item5_figure1_UserResponses

```
On to the statistical comparison: for Likert-scale, we want a non-parametric statistical test for ordinal data, that's the WilcoxonMannWhitney U test.

```{r echo=FALSE, fig.height = 3, fig.width = 5, fig.align = "center"}

# extract response numbers per participant
df_survey_subjHelpfulness_responses = df_survey_item5[df_survey_item5$itemNo==20,]
df_survey_subjHelpfulness_responses = df_survey_subjHelpfulness_responses[!df_survey_subjHelpfulness_responses$checked==0,]
# take out "prefer not to answer" replies
df_survey_subjHelpfulness_responses = df_survey_subjHelpfulness_responses[!df_survey_subjHelpfulness_responses$responseNo==6,]


# treat as numeric to compute stats
df_survey_subjHelpfulness_responses$responseNo=as.numeric(df_survey_subjHelpfulness_responses$responseNo)
# df_survey_subjUsability_responses$responseNo=as.numeric(df_survey_subjUsability_responses$responseNo)

# compute summary stats (mean, sd, sem)
df_survey_subjHelpfulness_summary=data_summary(df_survey_subjHelpfulness_responses, varname="responseNo", 
                    groupnames=c("group"))

# df_survey_subjUsability_summary=data_summary(df_survey_subjUsability_responses, varname="responseNo", 
#                     groupnames=c("group"))

# for plotting:
df_survey_subjHelpUsability_responses = df_survey_item5[!df_survey_item5$checked==0,]
df_survey_subjHelpUsability_responses = df_survey_subjHelpUsability_responses[!df_survey_subjHelpUsability_responses$responseNo==6,]
df_survey_subjHelpUsability_responses$responseNo=as.numeric(df_survey_subjHelpUsability_responses$responseNo)

# plot distribution
item5_figure2_UserResponses_violin = ggplot(df_survey_subjHelpUsability_responses, aes(x=group, y=responseNo, color=group, fill=group)) + 
  geom_violin(scale = "count")+
  geom_boxplot(width=0.1)+
  #geom_jitter(height = 0, width = 0.1)+ # ADD THIS TO DISPLAY INDIVIDUAL DATA POINTS!
  facet_wrap(vars(itemNo),nrow = 1, ncol = 1,labeller=as_labeller(c(`20`="\"Preferences of explanations.\""))) +
  stat_summary(fun=mean, geom="point", shape=23, size=2, color="red")  +
  labs(x="Group", y = "Response")+
  scale_y_continuous(limits = c(1, 5),breaks=1:5, labels=c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree"))+
  theme_bw(base_size = 10)+
  scale_fill_manual("Group", values=alpha(c(Dcol,Ucol),0.2), labels = c("DiCE","UFCE"))+
  scale_color_manual("Group", values=c(Dcol,Ucol), labels = c("DiCE","UFCE"))+
  theme(plot.title = element_text(hjust = 0.5))

# save
#ggsave("Figures/item5_UserResponses_violin.pdf",width = 6, height = 4,)

# Stacked bar plot, the more appropriate visualization for likert data:
# separate "high" and "low" values
lows=likert_item5[as.numeric(likert_item5$responseNo)<4,]
highs=likert_item5[as.numeric(likert_item5$responseNo)>2,]
# NOTE: we take response no 6 out here, after percentages were computed
# THUS, THE RESPONSES WILL NOT SUM UP TO 100% ID PEOPLE CHOSE NOT TO ANSWER!
highs=highs[!highs$responseNo==6,]
  
# divide neutral category by 2 for plotting:
lows$PercUsersChecked[lows$responseNo==3]=lows$PercUsersChecked[lows$responseNo==3]/2
highs$PercUsersChecked[highs$responseNo==3]=highs$PercUsersChecked[highs$responseNo==3]/2

item5_figure2_UserResponses_stackedBar = ggplot() + scale_x_discrete(labels=c("D"="DiCE", "U"="UFCE")) +
  # annotation:
  annotate("rect", xmin = 1.6, xmax = 2.4, ymin = -100, ymax = 100, alpha=0.2, fill = Ucol)+
  # annotate("rect", xmin = 0.6, xmax = 1.4, ymin = -100, ymax = 100, alpha=0.2, fill = Ccol)+
  annotate("rect", xmin = 0.6, xmax = 1.4, ymin = -100, ymax = 100, alpha=0.2, fill = Dcol)+
  # geom_bar, add data high:
  geom_bar(data=highs[order(highs$responseNo, decreasing = F),], aes(x = group, y=PercUsersChecked, fill=responseNo, group=group), position="stack", stat="identity",width = 0.5) +
  # add border for high values:
  stat_summary(data=highs[order(highs$responseNo, decreasing = F),], aes(x = group, y = PercUsersChecked),
               fun = sum,geom = "col",colour = "black",fill=NA,width = 0.5,size=0.1)+
  # geom_bar, add data low:
  geom_bar(data=lows[order(lows$responseNo, decreasing = T),], aes(x = group, y=-PercUsersChecked, fill=responseNo, group=group), position="stack", stat="identity",width = 0.5) +
  # add border for high values:
  stat_summary(data=lows[order(lows$responseNo, decreasing = T),], aes(x = group, y=-PercUsersChecked),
               fun = sum,geom = "col",colour = "black",fill=NA,width = 0.5,size=0.1)+
  # flip coordinates:
  coord_flip(xlim=c(0.99,2.3)) +
  # more aesthetics:
  geom_hline(yintercept = 0, color =c("black"),size=0.1) +
  facet_wrap(vars(itemNo),nrow = 3, ncol = 1,labeller=as_labeller(c(`20`="\"I like using the suggestions (explanation preference).\"")))+
  theme_bw(base_size = 10)+
theme(legend.position = "bottom",legend.title=element_blank(),legend.background = element_rect(fill="gray90", size=.5, linetype="dotted"),plot.title = element_text(hjust = 0.5))+
  labs(x="Group", y ="% of users")+
  scale_fill_manual("User response", values = likert_Okabe_Ito_palette,labels = c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree"))+
  scale_color_manual("Group", values=c(Dcol,Ucol), labels = c("DiCE","UFCE"))+
  scale_y_continuous(labels=c(100,50,0,50,100))

# save
ggsave("Figures/item20_UserResponses_stackedBar.pdf",width = 5, height = 3,)
item5_figure2_UserResponses_stackedBar

# show plots
# print("Mean user response for subjective helpfulness / usability:")
# H2.1_figure2_UserResponses_violin
# H2.1_figure2_UserResponses_stackedBar

# # run stats, helpfulness judgements:
item5t="Wilcox"
item5test=uk_wilcox.test(df_survey_subjHelpfulness_responses$responseNo[df_survey_subjHelpfulness_responses$group=="U"],df_survey_subjHelpfulness_responses$responseNo[df_survey_subjHelpfulness_responses$group=="D"],paired=FALSE,exact=FALSE)
item5effsize=item5test$z_val/(sqrt(nrow(df_survey_subjHelpfulness_responses)))
#
matchingRes=paste(matchingRes,paste("\n","item_20_Userresponses",sep=""),"NA",item5t,item5test$p.value,item5effsize,sep = ",")

print(df_survey_subjHelpfulness_summary$mean[df_survey_subjHelpfulness_summary$group=="U"])
print(df_survey_subjHelpfulness_summary$sem[df_survey_subjHelpfulness_summary$group=="U"])

print(df_survey_subjHelpfulness_summary$mean[df_survey_subjHelpfulness_summary$group=="D"])
print(df_survey_subjHelpfulness_summary$sem[df_survey_subjHelpfulness_summary$group=="D"])

print(item5test$p.value)
print(item5test$statistic)
print(item5effsize)
```
The analysis revealed:

* Is there a significant difference in in user responses for the prefeence of the explanations? 

We compared responses users in UFCE (M = `r df_survey_subjHelpfulness_summary$mean[df_survey_subjHelpfulness_summary$group=="U"]`, SEM = `r df_survey_subjHelpfulness_summary$sem[df_survey_subjHelpfulness_summary$group=="U"]`) and users in the DiCE (M = `r df_survey_subjHelpfulness_summary$mean[df_survey_subjHelpfulness_summary$group=="D"]`, SEM = `r df_survey_subjHelpfulness_summary$sem[df_survey_subjHelpfulness_summary$group=="D"]`) using a WilcoxonMannWhitney U test. This showed: U=`r item5test$statistic `, p=`r item5test$p.value `, r = `r item5effsize `

```{r echo=FALSE, fig.height = 3, fig.width = 5, fig.align = "center"}
# add significance annotation to likert plots:

anno_df <- data.frame(label = c("n.s.(p=0.110)"),itemNo   = c(5))
item5_figure2_UserResponses_stackedBar_anno = item5_figure2_UserResponses_stackedBar + geom_text(
  data = anno_df, mapping = aes(x = Inf, y = -Inf, label = label), hjust = -0.1, vjust = 1.5, size=2, fontface = "italic")

# save
ggsave("Figures/item20_UserResponses_stackedBar_anno_EXP.pdf",width = 5, height = 3,)

# show plots
print("Mean user response for help button and understanding of suggestions:")
item5_figure2_UserResponses_stackedBar_anno

```



#### so on...
```{r echo=FALSE, eval=FALSE}
# df_survey_subjUsability
# users_help <- df_survey_subjUsability$userId[df_survey_subjUsability$responseNo==4 & df_survey_subjUsability$checked==1]
# 
# # Step 3: Extract scores for users who answered 'yes'
# scores_help <- filtered_data[filtered_data$userId %in% users_help, ]
# scores_help
# # Step 4: Perform analysis (e.g., calculate average score for each group)
# average_score_yes <- mean(filtered_data$fitness_score[filtered_data$userId %in% users_help])
# # Output results
# cat("Average score for users who find Feedback helpful:", average_score_yes, "\n")
```

```{r echo=FALSE, warning=FALSE, fig.height = 5.5, fig.width = 4.5, eval=FALSE}

# # subset to get only relevant data
# df_survey_subjUsability=df_survey[(df_survey$itemNo==8),]
# 
# # set itemNo and responseNo to factors, too
# df_survey_subjUsability$itemNo=as.factor(df_survey_subjUsability$itemNo)
# df_survey_subjUsability$responseNo=as.factor(df_survey_subjUsability$responseNo)
# 
# summary(df_survey_subjUsability)
# 
# # summarize to get overview values of frequencies and percentages
# df_survey_subjUsability_summary=dplyr::summarise(group_by(df_survey_subjUsability, itemNo, responseNo),
#           SumChecks=sum(checked),
#           PercUsersChecked=100*(sum(checked)/length(unique(userId))),
#           .groups = 'drop')
# 
# # display frequency as raw counts
# H2_1_p_FreqUserResponses = ggplot(data=df_survey_subjUsability_summary, aes(x=responseNo,fill = itemNo)) + 
#   geom_bar(aes(y = SumChecks),stat="identity",position = position_dodge(preserve = "single"))+
#   facet_wrap(vars(itemNo),nrow = 2, ncol = 1,labeller=as_labeller(c(`8`="\"I could'nt use Feedback.\"")))+
#   labs(title="Subjective not helpfulness / usability of CFEs",x="", y = "Frequency of answer")+
#   theme_bw(base_size = 10)+
#   #scale_fill_manual("Group", values=c(Ccol,Pcol), labels = c("Control", "CFE"))+
#   scale_x_discrete(breaks=1:6, labels=c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree","Prefer not\nto answer"))+
#   theme(plot.title = element_text(hjust = 0.5),axis.text.x = element_text(angle = 60,hjust = 0.95))
# 
# # display frequency as percentage of all per group users (how many % of explanation users picked plant 1?)
# H2_1_p_PercUserResponses = ggplot(data=df_survey_subjUsability_summary, aes(x=responseNo,fill = itemNo)) + 
#   geom_bar(aes(y = PercUsersChecked),stat="identity",position = position_dodge(preserve = "single"))+
#   facet_wrap(vars(itemNo),nrow = 2, ncol = 1,labeller=as_labeller(c(`8`="\"I could'nt use Feedback.\"")))+
#   labs(title="Subjective not helpfulness / usability of CFEs",x="", y = "% of users per group")+
#   theme_bw(base_size = 10)+
#   #scale_fill_manual("Group", values=c(Ccol,Pcol), labels = c("Control", "CFE"))+
#   scale_x_discrete(breaks=1:6, labels=c("Strongly\ndisagree","Disagree","Neutral","Agree","Strongly\nagree","Prefer not\nto answer"))+
#   theme(plot.title = element_text(hjust = 0.5),axis.text.x = element_text(angle = 60,hjust = 0.95))
# 
# # safe summary to generate likert plots:
# likert_subjHelpUsability=df_survey_subjUsability_summary
# 
# # put all plots together
# H2.1_figure1_UserResponses <- ggarrange(H2_1_p_FreqUserResponses,H2_1_p_PercUserResponses,
#                     ncol = 1, nrow = 2)
# 
# # save
# ggsave("Figures/new/H2_subjective_not_helpfulness.pdf",width = 5, height = 6,)
# 
# # show
# print("Display figures showing user responses in relevant survey items:")
# H2.1_figure1_UserResponses

```
```{r echo=FALSE, eval=FALSE}
# df_survey_subjUsability
# df_survey_subjUsability_summary=dplyr::summarise(group_by(df_survey_subjUsability, itemNo, responseNo),
#           SumChecks=sum(checked),
#           PercUsersChecked=100*(sum(checked)/length(unique(userId))),
#           .groups = 'drop')
# df_survey_subjUsability_summary
# filtered_data
```

```{r echo=FALSE, eval=FALSE}

# 
# # Identify users who disagree
# users_nohelp <- df_survey_subjUsability$userId[df_survey_subjUsability$responseNo == 4 & df_survey_subjUsability$checked==1]
# 
# # Extract scores for users who answered 'no'
# scores_nohelp <- filtered_data[filtered_data$userId %in% users_nohelp, ]
# 
# # Perform analysis (e.g., calculate average score for each group)
# average_score_yes <- mean(filtered_data$fitness_score[!filtered_data$userId %in% users_nohelp])
# #average_score_no <- mean(scores_nohelp$fitness_score)
# 
# # Output results
# cat("Average score for users who find Feedback not helpful:", average_score_yes, "\n")
# #cat("Average score for users who answered 'no':", average_score_no, "\n")

```
```{r echo=FALSE, eval=FALSE}
# # Identify users who answered 'no'
# users_nohelp <- df_survey_subjUsability$userId[df_survey_subjUsability$responseNo == 2 & df_survey_subjUsability$checked==1]
# 
# # Extract scores for users who answered 'no'
# scores_nohelp <- filtered_data[filtered_data$userId %in% users_nohelp, ]
# 
# # Perform analysis (e.g., calculate average score for each group)
# average_score_yes <- mean(filtered_data$fitness_score[!filtered_data$userId %in% users_nohelp])
# #average_score_no <- mean(scores_nohelp$fitness_score)
# 
# # Output results
# cat("Average score for users who disagree to Feedback could'nt help:", average_score_yes, "\n")
# #cat("Average score for users who answered 'no':", average_score_no, "\n")
```


```{r echo=FALSE, eval=FALSE}

# 
# # Read the CSV file
# perf_source = list.files(path = "C:\\Users\\laboratorio\\Documents\\EXPFDB\\BackEnd\\LogData", pattern="results.csv",full.names=TRUE)
# df_results=read.csv(perf_source, header=TRUE)
# 
# subset_data <- df_results[, c("userId", "incurredCost_UFCE", "incurredCost_DiCE")]
# 
# # Create a new column with modified user IDs
# subset_data$modifiedUserId <- paste("", 1:nrow(subset_data), sep = "")
# 
# # Melt the data frame to long format for better plotting
# melted_data <- reshape2::melt(subset_data, id.vars = c("userId", "modifiedUserId"))
# 
# # Plot each row separately
# ggplot(melted_data, aes(x = modifiedUserId, y = value, color = variable)) +
#   geom_point() +
#   labs(title = "Scatterplot of columnA and columnB for Each Row",
#        x = "Modified User ID",
#        y = "Values",
#        color = "Variable") +
#   scale_x_discrete(labels = melted_data$modifiedUserId)

```
```{r echo=FALSE, eval=FALSE}


# subset_data <- df_results[df_results$userId %in% unique(df_results$userId)[0:10], c("userId", "incurredCost_UFCE", "incurredCost_DiCE")]
# 
# # Create a new column with modified user IDs
# subset_data$modifiedUserId <- paste("", 1:nrow(subset_data), sep = "")
# 
# # Convert 'columnA' and 'columnB' to numeric if needed
# subset_data$incurredCost_UFCE <- as.numeric(subset_data$incurredCost_UFCE)
# subset_data$incurredCost_DiCE <- as.numeric(subset_data$incurredCost_DiCE)
# 
# # Melt the data frame to long format for better plotting
# melted_data <- reshape2::melt(subset_data, id.vars = c("userId", "modifiedUserId"))
# 
# # Check the structure of melted_data
# str(melted_data)
# 
# # Plot each row separately with lines connecting the points
# ggplot(melted_data, aes(x = modifiedUserId, y = value, color = variable, group = interaction(userId, variable))) +
#   geom_line() +
#   #geom_text(aes(label = modifiedUserId), vjust = -0.5, hjust = -0.5, color = "black", size = 3) +  # Annotation
#   labs(title = "Line Plot of columnA and columnB for Each Row (First 5 Users)",
#        x = "Modified User ID",
#        y = "Values",
#        color = "Variable") +
#   scale_x_discrete(labels = melted_data$modifiedUserId)  # Ensure x-axis labels are modified user IDs
# 

```

